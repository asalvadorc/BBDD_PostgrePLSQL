{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Programaci\u00f3 en PostgreSQL Llicenciat sota la Llic\u00e8ncia Creative Commons Reconeixement NoComercial CompartirIgual 3.0","title":"Programaci\u00f3 en PostgreSQL"},{"location":"#programacio-en-postgresql","text":"Llicenciat sota la Llic\u00e8ncia Creative Commons Reconeixement NoComercial CompartirIgual 3.0","title":"Programaci\u00f3 en PostgreSQL"},{"location":"0_nota_inicial/","text":"0. DDL, DML de la BD per als exercicis. En aquest tema tamb\u00e9 construirem molts objectes, per tant podem \"boicotejar- nos\" entre nosaltres si utilitzem tots el mateix usuari. \u00c9s per aix\u00f2 que en aquest tema tots els exemples i tots els exercicis els farem sobre un usuari (i contrasenya) i una Base de Dades anomenada geo_grup_9999x , on heu de substituir grup pel codi del vostre grup, 9999 per les 4 \u00faltimes xifres del vostre DNI, i la x per la lletra del vostre NIF. La connexi\u00f3 ser\u00e0 per tant: Servidor: 89.36.214.106 Usuari: geo_grup_9999x (on grup \u00e9s el codi del vostre grup, 9999 s\u00f3n les 4 \u00faltimes xifres del vostre DNI, i x la vostra lletra del NIF) Contrasenya: geo_grup_9999x (el mateix d'abans) Base de Dades: geo_grup_9999x (el mateix d'abans) Ac\u00ed teniu les sent\u00e8ncies de creaci\u00f3 dels objectes que us faran falta: Creaci\u00f3 de la taula COMARQUES : CREATE TABLE public.comarques ( nom_c varchar(50) NOT NULL, provincia varchar(25) NULL, CONSTRAINT cp_com PRIMARY KEY (nom_c)); Creaci\u00f3 de la taula POBLACIONS : CREATE TABLE public.poblacions ( cod_m numeric(5) NOT NULL, nom varchar(50) NOT NULL, poblacio numeric(6) NULL, extensio numeric(6, 2) NULL, altura numeric(4) NULL, longitud varchar(50) NULL, latitud varchar(50) NULL, llengua bpchar(1) NULL, nom_c varchar(50) NULL, CONSTRAINT cp_pobl PRIMARY KEY (cod_m), CONSTRAINT ce_pob_com FOREIGN KEY (nom_c) REFERENCES public.comarques(nom_c) ON UPDATE CASCADE); Creaci\u00f3 de la taula INSTITUTS : CREATE TABLE public.instituts ( codi varchar(8) NOT NULL, nom varchar(60) NULL, adreca varchar(100) NULL, numero varchar(5) NULL, codpostal numeric(5) NULL, cod_m numeric(5) NULL, CONSTRAINT cp_ins PRIMARY KEY (codi), CONSTRAINT ce_ins_pob FOREIGN KEY (cod_m) REFERENCES public.poblacions(cod_m)); Inserci\u00f3 de dades en la taula COMARQUES : COMARQUES.sql Inserci\u00f3 de dades en la taula POBLACIONS : POBLACIONS.sql Inserci\u00f3 de dades en la taula INSTITUTS : INSTITUTS.sql Creaci\u00f3 de la taula PROVINCIES : CREATE TABLE PROVINCIES AS SELECT provincia, SUM(poblacio) AS habitants, SUM(Q) AS instituts FROM (COMARQUES INNER JOIN POBLACIONS ON COMARQUES.nom_c=POBLACIONS.nom_c) LEFT JOIN (SELECT cod_m, count(*) AS Q FROM INSTITUTS GROUP BY cod_m) I ON POBLACIONS.cod_m=I.cod_m GROUP BY provincia; Creaci\u00f3 dels dominis hemi_lat , graus_lat , i min_seg : CREATE DOMAIN hemi_lat AS char(1) CHECK (VALUE IN ('N','S')); CREATE DOMAIN graus_lat AS numeric(2) CHECK (VALUE BETWEEN 0 AND 90); CREATE DOMAIN min_seg AS numeric(2) CHECK (VALUE BETWEEN 0 AND 59); Creaci\u00f3 del tipus lat : CREATE TYPE lat AS ( h hemi_lat, g graus_lat, m min_seg, s min_seg ); Creaci\u00f3 de la taula POBLACIONS3 : CREATE TABLE POBLACIONS3 ( nom VARCHAR(50) CONSTRAINT cp_pob3 PRIMARY KEY, latitud lat, comarca varchar(50) ); Llicenciat sota la Llic\u00e8ncia Creative Commons Reconeixement NoComercial CompartirIgual 3.0","title":"0. DDL, DML de la BD per als exercicis"},{"location":"0_nota_inicial/#0-ddl-dml-de-la-bd-per-als-exercicis","text":"En aquest tema tamb\u00e9 construirem molts objectes, per tant podem \"boicotejar- nos\" entre nosaltres si utilitzem tots el mateix usuari. \u00c9s per aix\u00f2 que en aquest tema tots els exemples i tots els exercicis els farem sobre un usuari (i contrasenya) i una Base de Dades anomenada geo_grup_9999x , on heu de substituir grup pel codi del vostre grup, 9999 per les 4 \u00faltimes xifres del vostre DNI, i la x per la lletra del vostre NIF. La connexi\u00f3 ser\u00e0 per tant: Servidor: 89.36.214.106 Usuari: geo_grup_9999x (on grup \u00e9s el codi del vostre grup, 9999 s\u00f3n les 4 \u00faltimes xifres del vostre DNI, i x la vostra lletra del NIF) Contrasenya: geo_grup_9999x (el mateix d'abans) Base de Dades: geo_grup_9999x (el mateix d'abans) Ac\u00ed teniu les sent\u00e8ncies de creaci\u00f3 dels objectes que us faran falta: Creaci\u00f3 de la taula COMARQUES : CREATE TABLE public.comarques ( nom_c varchar(50) NOT NULL, provincia varchar(25) NULL, CONSTRAINT cp_com PRIMARY KEY (nom_c)); Creaci\u00f3 de la taula POBLACIONS : CREATE TABLE public.poblacions ( cod_m numeric(5) NOT NULL, nom varchar(50) NOT NULL, poblacio numeric(6) NULL, extensio numeric(6, 2) NULL, altura numeric(4) NULL, longitud varchar(50) NULL, latitud varchar(50) NULL, llengua bpchar(1) NULL, nom_c varchar(50) NULL, CONSTRAINT cp_pobl PRIMARY KEY (cod_m), CONSTRAINT ce_pob_com FOREIGN KEY (nom_c) REFERENCES public.comarques(nom_c) ON UPDATE CASCADE); Creaci\u00f3 de la taula INSTITUTS : CREATE TABLE public.instituts ( codi varchar(8) NOT NULL, nom varchar(60) NULL, adreca varchar(100) NULL, numero varchar(5) NULL, codpostal numeric(5) NULL, cod_m numeric(5) NULL, CONSTRAINT cp_ins PRIMARY KEY (codi), CONSTRAINT ce_ins_pob FOREIGN KEY (cod_m) REFERENCES public.poblacions(cod_m)); Inserci\u00f3 de dades en la taula COMARQUES : COMARQUES.sql Inserci\u00f3 de dades en la taula POBLACIONS : POBLACIONS.sql Inserci\u00f3 de dades en la taula INSTITUTS : INSTITUTS.sql Creaci\u00f3 de la taula PROVINCIES : CREATE TABLE PROVINCIES AS SELECT provincia, SUM(poblacio) AS habitants, SUM(Q) AS instituts FROM (COMARQUES INNER JOIN POBLACIONS ON COMARQUES.nom_c=POBLACIONS.nom_c) LEFT JOIN (SELECT cod_m, count(*) AS Q FROM INSTITUTS GROUP BY cod_m) I ON POBLACIONS.cod_m=I.cod_m GROUP BY provincia; Creaci\u00f3 dels dominis hemi_lat , graus_lat , i min_seg : CREATE DOMAIN hemi_lat AS char(1) CHECK (VALUE IN ('N','S')); CREATE DOMAIN graus_lat AS numeric(2) CHECK (VALUE BETWEEN 0 AND 90); CREATE DOMAIN min_seg AS numeric(2) CHECK (VALUE BETWEEN 0 AND 59); Creaci\u00f3 del tipus lat : CREATE TYPE lat AS ( h hemi_lat, g graus_lat, m min_seg, s min_seg ); Creaci\u00f3 de la taula POBLACIONS3 : CREATE TABLE POBLACIONS3 ( nom VARCHAR(50) CONSTRAINT cp_pob3 PRIMARY KEY, latitud lat, comarca varchar(50) ); Llicenciat sota la Llic\u00e8ncia Creative Commons Reconeixement NoComercial CompartirIgual 3.0","title":"0. DDL, DML de la BD per als exercicis."},{"location":"1_introducci/","text":"1. Introducci\u00f3 Una vegada vist amb suficient profunditat el SQL, anem a enfocar l'atac a una base de dades des d'un altre punt de vista. No com un comando que l'executem i ens d\u00f3na la resposta, sin\u00f3 des d'un llenguatge procedimental, amb les estructures de control pr\u00f2pies d'aquestos (condicionals, bucles, funcions, ...), per\u00f2 accedint \u00f2bviament a les dades. Ara, quan fem una consulta obtindrem un conjunt de dades al qual anomenarem cursor , i que segurament l'haurem de rec\u00f3rrer des del principi fins al final per a fer el tractament que siga. La part b\u00e0sica de tot a\u00e7\u00f2 ser\u00e0 la construcci\u00f3 de funcions. Aquestes es poden construir utilitzant molts llenguatges, comen\u00e7ant per SQL , on agruparem en una funci\u00f3 unes quantes sent\u00e8ncies SQL o una sent\u00e8ncia complicada. Anem a veure algun exemple, sobre l'usuari geo_grup_9999x , b\u00e9 des de psql o b\u00e9 des d'una finestra de SQL de DBeaver , que el que fa \u00e9s sumar la poblaci\u00f3 dels pobles de la comarca passada com a par\u00e0metre. Hem utilitzat l'opci\u00f3 CREATE OR REPLACE , aix\u00ed en cas que estiga ja creada, dons la substituirem. CREATE OR REPLACE FUNCTION gent_com(text) RETURNS numeric AS ' SELECT SUM(poblacio) FROM POBLACIONS WHERE nom_c=$1; ' LANGUAGE SQL; I ara, aix\u00ed ens dir\u00e0 quina \u00e9s la poblaci\u00f3 de Baix Maestrat : SELECT gent_com('Baix Maestrat'); O una altra tamb\u00e9 interessant, on traurem totes les comarques amb la seua poblaci\u00f3, utilitzant la funci\u00f3 anterior: SELECT nom_c,gent_com(nom_c) FROM COMARQUES; Per\u00f2 on realment traurem profit \u00e9s amb els llenguatges procedimentals. Podr\u00edem triar entre molts: C , Tcl , Perl , Python , ... En aquest curs optarem per PL/pgSQL ( ProceduraL PostGreSQL ). En versions anteriors podia passar que s'haguera de preparar la Base de Dades per a utilitzar el llenguatge. \u00c9s a dir, podia passar que no estiguera disponible el llenguatge de programaci\u00f3 en la Base de Dades. Aleshores s'havia d'instal\u00b7lar amb la sent\u00e8ncia: CREATE PROCEDURAL LANGUAGE plpgsql; Per\u00f2 no ser\u00e0 el nostre cas . Podem utilitzar sense problemes tant el llenguatge SQL com el PL/pgSQL , que \u00e9s el que realment ens interessa. Llicenciat sota la Llic\u00e8ncia Creative Commons Reconeixement NoComercial CompartirIgual 3.0","title":"1. Introducci\u00f3"},{"location":"1_introducci/#1-introduccio","text":"Una vegada vist amb suficient profunditat el SQL, anem a enfocar l'atac a una base de dades des d'un altre punt de vista. No com un comando que l'executem i ens d\u00f3na la resposta, sin\u00f3 des d'un llenguatge procedimental, amb les estructures de control pr\u00f2pies d'aquestos (condicionals, bucles, funcions, ...), per\u00f2 accedint \u00f2bviament a les dades. Ara, quan fem una consulta obtindrem un conjunt de dades al qual anomenarem cursor , i que segurament l'haurem de rec\u00f3rrer des del principi fins al final per a fer el tractament que siga. La part b\u00e0sica de tot a\u00e7\u00f2 ser\u00e0 la construcci\u00f3 de funcions. Aquestes es poden construir utilitzant molts llenguatges, comen\u00e7ant per SQL , on agruparem en una funci\u00f3 unes quantes sent\u00e8ncies SQL o una sent\u00e8ncia complicada. Anem a veure algun exemple, sobre l'usuari geo_grup_9999x , b\u00e9 des de psql o b\u00e9 des d'una finestra de SQL de DBeaver , que el que fa \u00e9s sumar la poblaci\u00f3 dels pobles de la comarca passada com a par\u00e0metre. Hem utilitzat l'opci\u00f3 CREATE OR REPLACE , aix\u00ed en cas que estiga ja creada, dons la substituirem. CREATE OR REPLACE FUNCTION gent_com(text) RETURNS numeric AS ' SELECT SUM(poblacio) FROM POBLACIONS WHERE nom_c=$1; ' LANGUAGE SQL; I ara, aix\u00ed ens dir\u00e0 quina \u00e9s la poblaci\u00f3 de Baix Maestrat : SELECT gent_com('Baix Maestrat'); O una altra tamb\u00e9 interessant, on traurem totes les comarques amb la seua poblaci\u00f3, utilitzant la funci\u00f3 anterior: SELECT nom_c,gent_com(nom_c) FROM COMARQUES; Per\u00f2 on realment traurem profit \u00e9s amb els llenguatges procedimentals. Podr\u00edem triar entre molts: C , Tcl , Perl , Python , ... En aquest curs optarem per PL/pgSQL ( ProceduraL PostGreSQL ). En versions anteriors podia passar que s'haguera de preparar la Base de Dades per a utilitzar el llenguatge. \u00c9s a dir, podia passar que no estiguera disponible el llenguatge de programaci\u00f3 en la Base de Dades. Aleshores s'havia d'instal\u00b7lar amb la sent\u00e8ncia: CREATE PROCEDURAL LANGUAGE plpgsql; Per\u00f2 no ser\u00e0 el nostre cas . Podem utilitzar sense problemes tant el llenguatge SQL com el PL/pgSQL , que \u00e9s el que realment ens interessa. Llicenciat sota la Llic\u00e8ncia Creative Commons Reconeixement NoComercial CompartirIgual 3.0","title":"1. Introducci\u00f3"},{"location":"2_plpgsql/","text":"2. PL/pgSQL PL/pgSQL vol dir llenguatge procedural de PostgreSQL. Canvia respecte el que hem vist, que sempre ha estat interactiu. El PL/pgSQL ens permetr\u00e0 construir funcions utilitzant un llenguatge procedimental, prou semblant al PASCAL i un poc paregut al Java. Podrem definir variables, crear bucles, ... per\u00f2 tamb\u00e9 incorporar sent\u00e8ncies de SQL; podrem definir cursors, que seran variables que ens permetran agafar l\u00ednia a l\u00ednia el resultat d\u2019un SELECT. Una de les aplicacions \u00e9s la creaci\u00f3 de TRIGGERS , que s\u00f3n m\u00f2duls de programa que s\u2019activen quan s\u2019acompleix una determinada condici\u00f3 de la Base de Dades, despr\u00e9s de la inserci\u00f3, modificaci\u00f3 o esborrat en una determinada taula. Qualsevol cosa que ens definim (funci\u00f3, Trigger,...), fins i tot un bloc de codi dins d'un bloc m\u00e9s gran, tindr\u00e0 la seg\u00fcent estructura: [DECLARE declaraci\u00f3 de variables] BEGIN Instruccions END; Tot anir\u00e0 per blocs: bloc de declaracions de variables, bloc del cos de la funci\u00f3 o procediment. I les sent\u00e8ncies de control tamb\u00e9 seran blocs, amb un principi (BEGIN) i un END al final. Totes les instruccions acaben en punt i coma. Observeu que ac\u00ed BEGIN i END no tenen el significat de SQL, \u00e9s a dir no serviran per a comen\u00e7ar o acabar una transacci\u00f3. Vejam un exemple (sobre l'usuari geo_grup_9999x ): CREATE OR REPLACE FUNCTION comentari() RETURNS void AS ' DECLARE i text := ''Joanet''; BEGIN i:=''Hola, '' || i; RAISE NOTICE ''%'',i; END; ' LANGUAGE PLPGSQL; RAISE NOTICE serveix per traure un comentari per pantalla. En l'entorn de DBeaver veurem el resultat en la pestanya Output . Hem de ser conscients que aquesta consulta \u00e9s de creaci\u00f3 d'una funci\u00f3. El resultat d'aquesta sent\u00e8ncia \u00e9s la creaci\u00f3 de la funci\u00f3, i per tant com a resultat \u00fanicament ens dir\u00e0 que l'ha creada, si tot ha anat b\u00e9 Nota Hem posat dues cometes simples en compte d'una en les constants alfanum\u00e8riques perqu\u00e8 tota la funci\u00f3 va declarada entre cometes simples. Per\u00f2 es pot modificar aquest delimitador de tota la funci\u00f3, i en compte de que siga la cometa, que siga una cadena amb $ davant i darrere, per exemple $cos$ . Aleshores no caldria posar dues cometes simples CREATE OR REPLACE FUNCTION comentari() RETURNS void AS $cos$ DECLARE i text := 'Joanet'; BEGIN i:='Hola, ' || i; RAISE NOTICE '%',i; END; $cos$ LANGUAGE plpgsql ; Si han hagut errors, els haurem de corregir (si l'error \u00e9s l\u00f2gic, s'haur\u00e0 creat igual la funci\u00f3; i si en modificar-la nom\u00e9s fem CREATE FUNCTION ... ens dir\u00e0 que ja est\u00e0 creada; per aix\u00f2 \u00e9s convenient posar CREATE OR REPLACE FUNCTION ...). Quan ja no hi hagen errors, la podrem executar amb la sent\u00e8ncia: SELECT comentari(); Recordem que en l'entorn de DBeaver veurem el resultat en la pestanya Output Llicenciat sota la Llic\u00e8ncia Creative Commons Reconeixement NoComercial CompartirIgual 3.0","title":"2. PL/pgSQL"},{"location":"2_plpgsql/#2-plpgsql","text":"PL/pgSQL vol dir llenguatge procedural de PostgreSQL. Canvia respecte el que hem vist, que sempre ha estat interactiu. El PL/pgSQL ens permetr\u00e0 construir funcions utilitzant un llenguatge procedimental, prou semblant al PASCAL i un poc paregut al Java. Podrem definir variables, crear bucles, ... per\u00f2 tamb\u00e9 incorporar sent\u00e8ncies de SQL; podrem definir cursors, que seran variables que ens permetran agafar l\u00ednia a l\u00ednia el resultat d\u2019un SELECT. Una de les aplicacions \u00e9s la creaci\u00f3 de TRIGGERS , que s\u00f3n m\u00f2duls de programa que s\u2019activen quan s\u2019acompleix una determinada condici\u00f3 de la Base de Dades, despr\u00e9s de la inserci\u00f3, modificaci\u00f3 o esborrat en una determinada taula. Qualsevol cosa que ens definim (funci\u00f3, Trigger,...), fins i tot un bloc de codi dins d'un bloc m\u00e9s gran, tindr\u00e0 la seg\u00fcent estructura: [DECLARE declaraci\u00f3 de variables] BEGIN Instruccions END; Tot anir\u00e0 per blocs: bloc de declaracions de variables, bloc del cos de la funci\u00f3 o procediment. I les sent\u00e8ncies de control tamb\u00e9 seran blocs, amb un principi (BEGIN) i un END al final. Totes les instruccions acaben en punt i coma. Observeu que ac\u00ed BEGIN i END no tenen el significat de SQL, \u00e9s a dir no serviran per a comen\u00e7ar o acabar una transacci\u00f3. Vejam un exemple (sobre l'usuari geo_grup_9999x ): CREATE OR REPLACE FUNCTION comentari() RETURNS void AS ' DECLARE i text := ''Joanet''; BEGIN i:=''Hola, '' || i; RAISE NOTICE ''%'',i; END; ' LANGUAGE PLPGSQL; RAISE NOTICE serveix per traure un comentari per pantalla. En l'entorn de DBeaver veurem el resultat en la pestanya Output . Hem de ser conscients que aquesta consulta \u00e9s de creaci\u00f3 d'una funci\u00f3. El resultat d'aquesta sent\u00e8ncia \u00e9s la creaci\u00f3 de la funci\u00f3, i per tant com a resultat \u00fanicament ens dir\u00e0 que l'ha creada, si tot ha anat b\u00e9 Nota Hem posat dues cometes simples en compte d'una en les constants alfanum\u00e8riques perqu\u00e8 tota la funci\u00f3 va declarada entre cometes simples. Per\u00f2 es pot modificar aquest delimitador de tota la funci\u00f3, i en compte de que siga la cometa, que siga una cadena amb $ davant i darrere, per exemple $cos$ . Aleshores no caldria posar dues cometes simples CREATE OR REPLACE FUNCTION comentari() RETURNS void AS $cos$ DECLARE i text := 'Joanet'; BEGIN i:='Hola, ' || i; RAISE NOTICE '%',i; END; $cos$ LANGUAGE plpgsql ; Si han hagut errors, els haurem de corregir (si l'error \u00e9s l\u00f2gic, s'haur\u00e0 creat igual la funci\u00f3; i si en modificar-la nom\u00e9s fem CREATE FUNCTION ... ens dir\u00e0 que ja est\u00e0 creada; per aix\u00f2 \u00e9s convenient posar CREATE OR REPLACE FUNCTION ...). Quan ja no hi hagen errors, la podrem executar amb la sent\u00e8ncia: SELECT comentari(); Recordem que en l'entorn de DBeaver veurem el resultat en la pestanya Output Llicenciat sota la Llic\u00e8ncia Creative Commons Reconeixement NoComercial CompartirIgual 3.0","title":"2. PL/pgSQL"},{"location":"3_declaraci_de_variables/","text":"3. Declaraci\u00f3 de variables S'han de declarar totes (excepte les variables comptador dels bucles FOR, com ja veurem en el seu moment) en el bloc DECLARE i els tipus v\u00e0lids s\u00f3n els de SQL (NUMERIC, CHAR, DATE, ...). Tamb\u00e9 es poden declarar de subtipus definits per l\u2019usuari, com per exemple lat . Aquesta \u00e9s la sintaxi de declaraci\u00f3 de variables: nom [CONSTANT] tipus [NOT NULL] [{DEFAULT | :=}expressi\u00f3]; Com veiem, i de forma opcional podem definir les variables com a: Constants , i aleshores el seu contingut no podr\u00e0 variar (haur\u00e0 de tenir valor inicial). No nul\u00b7les , i aleshores una assignaci\u00f3 del valor nul donar\u00e0 un error (haur\u00e0 de tenir valor inicial). Amb un valor inicial (a les variables declarades com a constants nom\u00e9s se'ls podran donar valors amb aquesta cl\u00e0usula). Per exemple : DECLARE v1 VARCHAR; v2 CONSTANT TEXT := 'Hola'; v3 NUMERIC(5) := 0; v4 DATE NOT NULL DEFAULT '7-7-77'; v5 lat; vec6 NUMERIC(5)[]; Si tenim, com en l'\u00faltim exemple, una variable que \u00e9s d'un tipus compost, la manera d'accedir a un camp ser\u00e0 separant la variable i el camp per un punt: v5.h . Ara no far\u00e0 falta posar la variable entre par\u00e8ntesis, com ens tocava fer en les sent\u00e8ncies SQL. L'\u00e0mbit de les variables \u00e9s el bloc on es declaren i els blocs \"fills\", \u00e9s a dir aquells blocs definits dins del bloc on est\u00e0 definida la variable. Si se'ls d\u00f3na un valor inicial, aquest valor s'assigna cada vegada que s'entra dins del bloc (no al principi de l'execuci\u00f3 de la funci\u00f3). Aix\u00f2 pot ser important, ja que en la mateixa execuci\u00f3 de la funci\u00f3 si s'entra m\u00e9s d'una vegada en el bloc, pot tenir resultats diferents. Per exemple: Utilitzem la funci\u00f3 que ja tenim creada gent_com (poblaci\u00f3 de la comarca especificada). La utilitzem per a inicialitzar una variable en el DECLARE, i executem aquest bloc dues vegades. Nom\u00e9s ens queda canviar la comarca entre les dues passades. CREATE OR REPLACE FUNCTION moltes_pobl() RETURNS void AS $cos$ DECLARE aux text := 'Marina Alta'; BEGIN FOR i IN 1..2 LOOP DECLARE n numeric := gent_com(aux); BEGIN RAISE NOTICE 'Comarca %: % habitants',aux,n; END; IF i=1 THEN aux:='Marina Baixa'; END IF; END LOOP; END; $cos$ LANGUAGE 'plpgsql'; I per a veure el resultat: SELECT moltes_pobl(); Recordeu que el resultat que traiem amb RAISE NOTICE es veu en la pestanya de Messages . Com veurem un poc m\u00e9s avant, a les funcions se'ls poden passar par\u00e0metres, per\u00f2 en el moment de definir-los tenim l'opci\u00f3 de posar nom\u00e9s de quin tipus s\u00f3n. La manera de nomenar-los dins de la funci\u00f3, d'aquesta manera, \u00e9s $1 , $2 , ... Per a no haver d'utilitzar uns noms tan impersonals, podem posar \u00e0lies en la zona de declaraci\u00f3: CREATE OR REPLACE FUNCTION iva(numeric) RETURNS numeric AS ' BEGIN RETURN $1 * 0.16; END; ' LANGUAGE plpgsql; SELECT iva(200); Ja que estem en la zona de declaraci\u00f3 de variables, anem a acabar de comentar la manera de definir variables. %TYPE permet definir variables del tipus equivalent a una altra variable ( v1 v2%TYPE; ). La utilitat real \u00e9s que jo puc definir una variable del mateix tipus que un camp d'una determinada taula, i no cal que recorde de quin tipus era aquell. Per exemple: v_lat poblacions.lat%TYPE; %ROWTYPE : la variable ser\u00e0 de tipus fila de la taula esmentada. Podrem utilitzar la variable amb camps, ja que equival a tota la fila. CREATE OR REPLACE FUNCTION loc_pobl(text) RETURNS void AS $cos$ DECLARE f poblacions%ROWTYPE; BEGIN SELECT * INTO f FROM POBLACIONS WHERE nom=$1; RAISE NOTICE 'Poblaci\u00f3: %',f.nom; RAISE NOTICE 'Latitud: %',f.latitud; RAISE NOTICE 'Longitud: %',f.longitud; END; $cos$ LANGUAGE 'plpgsql'; SELECT loc_pobl('Llucena'); RECORD \u00e9s tamb\u00e9 de tipus fila , per\u00f2 agafa la seua estructura en el moment d'efectuar-se la sent\u00e8ncia select. \u00c9s per tant molt m\u00e9s vers\u00e0til. CREATE OR REPLACE FUNCTION loc_pobl_2(text) RETURNS void AS $cos$ DECLARE f RECORD; BEGIN SELECT * INTO f FROM POBLACIONS WHERE nom=$1; RAISE NOTICE 'Poblaci\u00f3: %',f.nom; RAISE NOTICE 'Latitud: %',f.latitud; RAISE NOTICE 'Longitud: %',f.longitud; END; $cos$ LANGUAGE 'plpgsql'; SELECT loc_pobl_2('Llucena'); Llicenciat sota la Llic\u00e8ncia Creative Commons Reconeixement NoComercial CompartirIgual 3.0","title":"3. Declaraci\u00f3 de variables"},{"location":"3_declaraci_de_variables/#3-declaracio-de-variables","text":"S'han de declarar totes (excepte les variables comptador dels bucles FOR, com ja veurem en el seu moment) en el bloc DECLARE i els tipus v\u00e0lids s\u00f3n els de SQL (NUMERIC, CHAR, DATE, ...). Tamb\u00e9 es poden declarar de subtipus definits per l\u2019usuari, com per exemple lat . Aquesta \u00e9s la sintaxi de declaraci\u00f3 de variables: nom [CONSTANT] tipus [NOT NULL] [{DEFAULT | :=}expressi\u00f3]; Com veiem, i de forma opcional podem definir les variables com a: Constants , i aleshores el seu contingut no podr\u00e0 variar (haur\u00e0 de tenir valor inicial). No nul\u00b7les , i aleshores una assignaci\u00f3 del valor nul donar\u00e0 un error (haur\u00e0 de tenir valor inicial). Amb un valor inicial (a les variables declarades com a constants nom\u00e9s se'ls podran donar valors amb aquesta cl\u00e0usula). Per exemple : DECLARE v1 VARCHAR; v2 CONSTANT TEXT := 'Hola'; v3 NUMERIC(5) := 0; v4 DATE NOT NULL DEFAULT '7-7-77'; v5 lat; vec6 NUMERIC(5)[]; Si tenim, com en l'\u00faltim exemple, una variable que \u00e9s d'un tipus compost, la manera d'accedir a un camp ser\u00e0 separant la variable i el camp per un punt: v5.h . Ara no far\u00e0 falta posar la variable entre par\u00e8ntesis, com ens tocava fer en les sent\u00e8ncies SQL. L'\u00e0mbit de les variables \u00e9s el bloc on es declaren i els blocs \"fills\", \u00e9s a dir aquells blocs definits dins del bloc on est\u00e0 definida la variable. Si se'ls d\u00f3na un valor inicial, aquest valor s'assigna cada vegada que s'entra dins del bloc (no al principi de l'execuci\u00f3 de la funci\u00f3). Aix\u00f2 pot ser important, ja que en la mateixa execuci\u00f3 de la funci\u00f3 si s'entra m\u00e9s d'una vegada en el bloc, pot tenir resultats diferents. Per exemple: Utilitzem la funci\u00f3 que ja tenim creada gent_com (poblaci\u00f3 de la comarca especificada). La utilitzem per a inicialitzar una variable en el DECLARE, i executem aquest bloc dues vegades. Nom\u00e9s ens queda canviar la comarca entre les dues passades. CREATE OR REPLACE FUNCTION moltes_pobl() RETURNS void AS $cos$ DECLARE aux text := 'Marina Alta'; BEGIN FOR i IN 1..2 LOOP DECLARE n numeric := gent_com(aux); BEGIN RAISE NOTICE 'Comarca %: % habitants',aux,n; END; IF i=1 THEN aux:='Marina Baixa'; END IF; END LOOP; END; $cos$ LANGUAGE 'plpgsql'; I per a veure el resultat: SELECT moltes_pobl(); Recordeu que el resultat que traiem amb RAISE NOTICE es veu en la pestanya de Messages . Com veurem un poc m\u00e9s avant, a les funcions se'ls poden passar par\u00e0metres, per\u00f2 en el moment de definir-los tenim l'opci\u00f3 de posar nom\u00e9s de quin tipus s\u00f3n. La manera de nomenar-los dins de la funci\u00f3, d'aquesta manera, \u00e9s $1 , $2 , ... Per a no haver d'utilitzar uns noms tan impersonals, podem posar \u00e0lies en la zona de declaraci\u00f3: CREATE OR REPLACE FUNCTION iva(numeric) RETURNS numeric AS ' BEGIN RETURN $1 * 0.16; END; ' LANGUAGE plpgsql; SELECT iva(200); Ja que estem en la zona de declaraci\u00f3 de variables, anem a acabar de comentar la manera de definir variables. %TYPE permet definir variables del tipus equivalent a una altra variable ( v1 v2%TYPE; ). La utilitat real \u00e9s que jo puc definir una variable del mateix tipus que un camp d'una determinada taula, i no cal que recorde de quin tipus era aquell. Per exemple: v_lat poblacions.lat%TYPE; %ROWTYPE : la variable ser\u00e0 de tipus fila de la taula esmentada. Podrem utilitzar la variable amb camps, ja que equival a tota la fila. CREATE OR REPLACE FUNCTION loc_pobl(text) RETURNS void AS $cos$ DECLARE f poblacions%ROWTYPE; BEGIN SELECT * INTO f FROM POBLACIONS WHERE nom=$1; RAISE NOTICE 'Poblaci\u00f3: %',f.nom; RAISE NOTICE 'Latitud: %',f.latitud; RAISE NOTICE 'Longitud: %',f.longitud; END; $cos$ LANGUAGE 'plpgsql'; SELECT loc_pobl('Llucena'); RECORD \u00e9s tamb\u00e9 de tipus fila , per\u00f2 agafa la seua estructura en el moment d'efectuar-se la sent\u00e8ncia select. \u00c9s per tant molt m\u00e9s vers\u00e0til. CREATE OR REPLACE FUNCTION loc_pobl_2(text) RETURNS void AS $cos$ DECLARE f RECORD; BEGIN SELECT * INTO f FROM POBLACIONS WHERE nom=$1; RAISE NOTICE 'Poblaci\u00f3: %',f.nom; RAISE NOTICE 'Latitud: %',f.latitud; RAISE NOTICE 'Longitud: %',f.longitud; END; $cos$ LANGUAGE 'plpgsql'; SELECT loc_pobl_2('Llucena'); Llicenciat sota la Llic\u00e8ncia Creative Commons Reconeixement NoComercial CompartirIgual 3.0","title":"3. Declaraci\u00f3 de variables"},{"location":"4_instruccions/","text":"4. Instruccions Nota Les instruccions que van a continuaci\u00f3 encara no les podrem practicar, perqu\u00e8 han de formar part d'alguna funci\u00f3. Les podrem practicar a partir de la pregunta seg\u00fcent Assignaci\u00f3 : es pot fer de dues maneres Directa, amb l\u2019operador := (a := 10; b := a * 0.5; ) Assignar el resultat d\u2019una consulta (una \u00fanica fila) a una variable o variables amb INTO . INTO pot anar abans o despr\u00e9s de les columnes seleccionades: SELECT Max(altura) INTO a FROM POBLACIONS; SELECT INTO a Max(altura) FROM POBLACIONS; SELECT Max(altura),Min(altura),Avg(altura) INTO a,b,c FROM POBLACIONS; Condicional IF condici\u00f3 THEN Sent\u00e8ncies; [ELSE sent\u00e8ncies;] END IF; Tamb\u00e9 es pot utilitzar ELSIF que equival a un ELSE seguit de IF. D'aquesta manera nom\u00e9s hi haur\u00e0 un END IF al final. \u00c9s la cosa m\u00e9s pareguda al CASE. IF condici\u00f31 THEN Sent\u00e8ncies1; ELSIF condici\u00f32 THEN Sent\u00e8ncies2; ELSE Sent\u00e8ncies3; END IF; Bucles : s\u2019aconsegueixen per mig de LOOP ...... END LOOP; Bucle incondicional LOOP Sent\u00e8ncies END LOOP; tal i com est\u00e0, el bucle \u00e9s infinit; per eixir EXIT o EXIT WHEN cond Bucle FOR FOR variable IN [REVERSE] valor_m\u00edn .. valor_m\u00e0x LOOP Sent\u00e8ncies END LOOP; La variable comptador no s'ha de declarar i nom\u00e9s t\u00e9 validesa dins del bucle. Bucle WHILE WHILE condici\u00f3 LOOP Sent\u00e8ncies END LOOP; Sent\u00e8ncies SQL : es poden executar sense problema totes aquelles sent\u00e8ncies que no tornen cap resultat (INSERT, UPDATE, DELETE, CREATE TABLE, ...). La sent\u00e8ncia SELECT, que s\u00ed que torna un valor s'ha d'utilitzar amb la cl\u00e0usula INTO (com ja hem vist), o dins de PERFORM (com ara veurem). Execuci\u00f3 d'altres funcions . En moltes ocasions ens far\u00e0 falta executar una altra funci\u00f3. Si aquesta torna un valor la posarem dins d'una sent\u00e8ncia (assignaci\u00f3, en una condici\u00f3, ...). Per\u00f2 i si no torna cap valor? El mateix podr\u00edem dir d'una sent\u00e8ncia SELECT (encara que la utilitat d'a\u00e7\u00f2 \u00e9s m\u00e9s dubtosa). Ho farem per mig de PERFORM, que executa una sent\u00e8ncia, ignorant el possible valor tornat per aquesta. Per exemple (recordeu que loc_pobl, la funci\u00f3 creada en la pregunta anterior, no torna cap valor, sin\u00f3 que ho trau per pantalla): PERFORM loc_pobl('A\u00edn'); PERFORM (SELECT * FROM POBLACIONS); Execuci\u00f3 en forma din\u00e0mica . Hi haur\u00e0 ocasions en que la sent\u00e8ncia SQL la voldrem construir en temps d'execuci\u00f3, \u00e9s a dir de forma din\u00e0mica. Aix\u00f2 ens ho permet EXECUTE , que el que fa es passar la cadena de car\u00e0cters que va a continuaci\u00f3 al motor SQL. Per exemple: EXECUTE 'SELECT ' || $2 || ' FROM ' || $1; De moment no fa res, perqu\u00e8 el resultat de la sent\u00e8ncia es perd, per\u00f2 ja veurem m\u00e9s avant la seua aplicaci\u00f3. Un altre exemple, on esborrar\u00edem les files d'una taula on un camp coincideix amb un valor (tot passat com a par\u00e0metres): EXECUTE 'DELETE FROM ' || $1 || ' WHERE ' || $2 || ' = ' || $3; Llicenciat sota la Llic\u00e8ncia Creative Commons Reconeixement NoComercial CompartirIgual 3.0","title":"4. Instruccions"},{"location":"4_instruccions/#4-instruccions","text":"Nota Les instruccions que van a continuaci\u00f3 encara no les podrem practicar, perqu\u00e8 han de formar part d'alguna funci\u00f3. Les podrem practicar a partir de la pregunta seg\u00fcent Assignaci\u00f3 : es pot fer de dues maneres Directa, amb l\u2019operador := (a := 10; b := a * 0.5; ) Assignar el resultat d\u2019una consulta (una \u00fanica fila) a una variable o variables amb INTO . INTO pot anar abans o despr\u00e9s de les columnes seleccionades: SELECT Max(altura) INTO a FROM POBLACIONS; SELECT INTO a Max(altura) FROM POBLACIONS; SELECT Max(altura),Min(altura),Avg(altura) INTO a,b,c FROM POBLACIONS; Condicional IF condici\u00f3 THEN Sent\u00e8ncies; [ELSE sent\u00e8ncies;] END IF; Tamb\u00e9 es pot utilitzar ELSIF que equival a un ELSE seguit de IF. D'aquesta manera nom\u00e9s hi haur\u00e0 un END IF al final. \u00c9s la cosa m\u00e9s pareguda al CASE. IF condici\u00f31 THEN Sent\u00e8ncies1; ELSIF condici\u00f32 THEN Sent\u00e8ncies2; ELSE Sent\u00e8ncies3; END IF; Bucles : s\u2019aconsegueixen per mig de LOOP ...... END LOOP; Bucle incondicional LOOP Sent\u00e8ncies END LOOP; tal i com est\u00e0, el bucle \u00e9s infinit; per eixir EXIT o EXIT WHEN cond Bucle FOR FOR variable IN [REVERSE] valor_m\u00edn .. valor_m\u00e0x LOOP Sent\u00e8ncies END LOOP; La variable comptador no s'ha de declarar i nom\u00e9s t\u00e9 validesa dins del bucle. Bucle WHILE WHILE condici\u00f3 LOOP Sent\u00e8ncies END LOOP; Sent\u00e8ncies SQL : es poden executar sense problema totes aquelles sent\u00e8ncies que no tornen cap resultat (INSERT, UPDATE, DELETE, CREATE TABLE, ...). La sent\u00e8ncia SELECT, que s\u00ed que torna un valor s'ha d'utilitzar amb la cl\u00e0usula INTO (com ja hem vist), o dins de PERFORM (com ara veurem). Execuci\u00f3 d'altres funcions . En moltes ocasions ens far\u00e0 falta executar una altra funci\u00f3. Si aquesta torna un valor la posarem dins d'una sent\u00e8ncia (assignaci\u00f3, en una condici\u00f3, ...). Per\u00f2 i si no torna cap valor? El mateix podr\u00edem dir d'una sent\u00e8ncia SELECT (encara que la utilitat d'a\u00e7\u00f2 \u00e9s m\u00e9s dubtosa). Ho farem per mig de PERFORM, que executa una sent\u00e8ncia, ignorant el possible valor tornat per aquesta. Per exemple (recordeu que loc_pobl, la funci\u00f3 creada en la pregunta anterior, no torna cap valor, sin\u00f3 que ho trau per pantalla): PERFORM loc_pobl('A\u00edn'); PERFORM (SELECT * FROM POBLACIONS); Execuci\u00f3 en forma din\u00e0mica . Hi haur\u00e0 ocasions en que la sent\u00e8ncia SQL la voldrem construir en temps d'execuci\u00f3, \u00e9s a dir de forma din\u00e0mica. Aix\u00f2 ens ho permet EXECUTE , que el que fa es passar la cadena de car\u00e0cters que va a continuaci\u00f3 al motor SQL. Per exemple: EXECUTE 'SELECT ' || $2 || ' FROM ' || $1; De moment no fa res, perqu\u00e8 el resultat de la sent\u00e8ncia es perd, per\u00f2 ja veurem m\u00e9s avant la seua aplicaci\u00f3. Un altre exemple, on esborrar\u00edem les files d'una taula on un camp coincideix amb un valor (tot passat com a par\u00e0metres): EXECUTE 'DELETE FROM ' || $1 || ' WHERE ' || $2 || ' = ' || $3; Llicenciat sota la Llic\u00e8ncia Creative Commons Reconeixement NoComercial CompartirIgual 3.0","title":"4. Instruccions"},{"location":"5_funcions/","text":"5. Funcions En PL/pgSQL no hi ha procediments. Nom\u00e9s hi ha funcions, encara que puguem declarar-les per a que no tornen cap valor ( void ). Nota La difer\u00e8ncia per tant entre un procediment i una funci\u00f3 \u00e9s que la segona torna un valor, mentre que el primer no. Per\u00f2 en PL/pgSQL nom\u00e9s hi ha funcions. La sintaxi general (i en principi per a qualsevol llenguatge) de la instrucci\u00f3 de creaci\u00f3 de funcions \u00e9s la seg\u00fcent: CREATE [OR REPLACE] FUNCTION nom_funci\u00f3 [(llista_par\u00e0metres)] RETURNS tipus_del_valor_tornat AS ' instruccions ' LANGUAGE llenguatge; on el llenguatge potser un dels definits (SQL, PL/pgSQL, ...). El cos de la funci\u00f3 pot anar entre cometes simples, o entre un separador que comence i acabe per $ (per exemple $cos$ ) i que ha de ser igual al principi i al final, com veurem en un exemple m\u00e9s avant. Concretament, en el cas de PL/pgSQL, podem refinar un poc m\u00e9s la sintaxi CREATE [OR REPLACE] FUNCTION nom_funci\u00f3 [(llista_par\u00e0metres)] RETURNS tipus_del_valor_tornat AS ' [DECLARE declaraci\u00f3 de variables] BEGIN instruccions RETURN expressi\u00f3 END; ' LANGUAGE plpgsql; Si la funci\u00f3 torna un valor (i per tant l'hem declarada com a que retorna un valor), la instrucci\u00f3 que ens permet retornar el valor \u00e9s RETURN Per exemple, anem a crear una funci\u00f3 que passe de pessetes a euros. Ho podem fer sobre la Base de Dades geo_999x : CREATE FUNCTION EUROS(n int4) RETURNS numeric AS ' BEGIN RETURN ROUND(n/166.386,2); END; ' LANGUAGE plpgsql; SELECT euros(1000); Els tipus de dades de tornada pot ser qualsevol, fins i tot un creat per l'usuari. I si volem que torne m\u00e9s d'un valor, podr\u00edem crear un tipus compost que abarque els valors que volem que torne. Tenim la possibilitat de posar noms als par\u00e0metres (en el cas anterior n), o no, i aleshores la manera de fer-los refer\u00e8ncia \u00e9s per mig de $1 per al primer par\u00e0metre, $2 per al segon, ... Aix\u00ed la mateixa funci\u00f3, sense gastar nom de par\u00e0metre quedaria: CREATE OR REPLACE FUNCTION EUROS2(int4) RETURNS numeric AS ' BEGIN RETURN ROUND($1/166.386,2); END; ' LANGUAGE plpgsql; Anem a veure un altre exemple: una funci\u00f3 que puga convertir una latitud en format text al tipus de dades que ens vam crear en el tema 6, part 3, el tipus lat . Les instruccions estan en el punt 0 (Nota inicial) I ara anem a fer la funci\u00f3 que passa de tipus Text a tipus lat : CREATE OR REPLACE FUNCTION text_a_lat(text) RETURNS lat as $COS$ DECLARE aux lat; BEGIN IF $1 IS NOT NULL THEN aux.g := SUBSTR($1,1,STRPOS($1,'\u00ba')-1); aux.m := SUBSTR($1, STRPOS($1,'\u00ba')+1, STRPOS($1,'''') - STRPOS($1,'\u00ba')-1); aux.s := SUBSTR($1, STRPOS($1,'''')+1, STRPOS($1,'\"') - STRPOS($1,'''')-1); aux.h := SUBSTR($1,STRPOS($1,'\"')+1); ELSE aux := (NULL,NULL,NULL,NULL); END IF; RETURN aux; END; $COS$ LANGUAGE plpgsql; Hem posat $COS$ per a delimitar el cos de la funci\u00f3, per evitar problemes amb les moltes cometes que hi ha. I quan busquem la cometa, doncs en posem 4: la primera i l'\u00faltima s\u00f3n obligat\u00f2ries i delimiten la constant alfanum\u00e8rica. I al mig en posem 2 m\u00e9s per a marcar la cometa. Podem provar a veure si va b\u00e9: SELECT nom,latitud,text_a_lat(latitud),nom_c FROM POBLACIONS; Si la funci\u00f3 va b\u00e9, fins i tot la podr\u00edem utilitzar per omplir la taula POBLACIONS3 (est\u00e0 creada en el punt 0. Nota inicial ), que l'hav\u00edem creada amb el tipus lat (ens convindria eliminar primer les possibles files que hi hagen creades). DELETE FROM POBLACIONS3; INSERT INTO POBLACIONS3 SELECT nom,text_a_lat(latitud),nom_c FROM POBLACIONS; La funci\u00f3 inversa sembla m\u00e9s f\u00e0cil. L'\u00fanic problema, en tot cas, \u00e9s controlar que minuts i segons sempre siguen de dues xifres. I en tot cas llevar espais en blanc que queden pel mig. I haurem d'anar amb compte amb la cometa. Nota En les pr\u00e0ctiques seg\u00fcents en moltes ocasions es diu \"traure per pantalla\". I s\u00f3n funcions que no tenen par\u00e0metre ni tornen cap valor. Encara que a\u00e7\u00f2 no ser\u00e0 el normal en PostgreSQL, per a practicar pot anar b\u00e9. La manera de crear aquestes funcions \u00e9s com en el seg\u00fcent exemple, en el qual creem una funci\u00f3 que trau per pantalla el n\u00famero PI: CREATE OR REPLACE FUNCTION traure_pi() RETURNS void as $COS$ begin raise notice 'El n\u00famero PI \u00e9s: %',PI(); end; $COS$ LANGUAGE 'plpgsql'; En aquesta ocasi\u00f3 hem posat moltes paraules en min\u00fascules, per a demostrar que no importen maj\u00fascules i min\u00fascules. El resultat, si \u00e9s que ho fem des de DBeaver, el veurem fent una altra consulta SQL posant SELECT traure_pi(); i el resultat el veur\u00edem en la pestanya Output , ja que hem provocat traure un missatge. Com veieu estem utilitzant la sent\u00e8ncia RAISE NOTICE , que la veurem millor en la pregunta 7 d'aquest tema, per\u00f2 que ja podem avan\u00e7ar que el que fa \u00e9s traure una l\u00ednia en la pestanya de missatges amb el comen\u00e7ament NOTICE: . Posarem entre cometes simples el text que volem mostrar, i per a traure el contingut d'una variable, posarem entre les cometes un % , i al final, separat per coma la variable de la qual volem mostrar el contingut. Podem posar m\u00e9s d'un %, i al final haurem de posar (separades per comes) tantes variables o expressions com % hem posat entre cometes. Ho veurem millor en els seg\u00fcents exemples. Un altre exemple, tamb\u00e9 d'una funci\u00f3 que no torna res, sin\u00f3 que \"trau per pantalla\" els n\u00fameros del 1 al 10: CREATE OR REPLACE FUNCTION deu() RETURNS VOID as $COS$ BEGIN FOR i IN 1..10 LOOP RAISE NOTICE '%',i; END LOOP; END; $COS$ LANGUAGE 'plpgsql'; Quan l'executem: SELECT deu(); Ens eixir\u00e0 aquest resultat en la pestanya de Output: Una variant seria traure els n\u00fameros del 1 al 10 i el seu doble. Observeu com posem 2 vegades % , i despr\u00e9s posem 2 coses a mostrar, separades per comes: i, i*2 CREATE OR REPLACE FUNCTION deu_doble() RETURNS VOID as $COS$ BEGIN FOR i IN 1..10 LOOP RAISE NOTICE 'N\u00famero: %. Doble: %',i,i*2; END LOOP; END; $COS$ LANGUAGE 'plpgsql'; SELECT deu_doble(); Exercicis En la Base de Dades geo_grup_9999x : Ex_1 - Crea una funci\u00f3 anomenada DEU_ Q , que traga els n\u00fameros del 1 al 10 i els seus quadrats . (Utilitza RAISE NOTICE ). Ex_2 - Fes una altra funci\u00f3, IMP , que traga per pantalla els n\u00fameros imparells del 1 al 50. (Utilitza RAISE NOTICE ). Ex_3 - Fes una funci\u00f3 anomenada TAULA_MULT , per a que traga la taula de multiplicar del par\u00e0metre que se li ha de passar. (Utilitza RAISE NOTICE ). Aquest podria ser el seu aspecte, en executar-la: Ex_4 - Fes una funci\u00f3, anomenada MAX2 , que tinga dos par\u00e0metres num\u00e8rics i que torne el m\u00e0xim entre aquestos dos. (Ara ja no s'ha d'utilitzar RAISE NOTICE ). Podeu comprovar el seu funcionament fent per exemple SELECT MAX(5,7); SELECT MAX(15,7) . Sempre ha de mostrar el m\u00e0xim dels dos. Ex_5 - Utilitza l'anterior per a crear MAX3 . Has d'utilitzar obligat\u00f2riament la funci\u00f3 MAX2 Ex_6 - ( Voluntari ) Fes la funci\u00f3 LAT_A_TEXT , tenint en compte que ha de quedar com en la taula POBLACIONS . Segurament la dificultat m\u00e9s gran ser\u00e0 aconseguir que apareguen les cometes despr\u00e9s dels minuts i dels segons. Llicenciat sota la Llic\u00e8ncia Creative Commons Reconeixement NoComercial CompartirIgual 3.0","title":"5. Funcions"},{"location":"5_funcions/#5-funcions","text":"En PL/pgSQL no hi ha procediments. Nom\u00e9s hi ha funcions, encara que puguem declarar-les per a que no tornen cap valor ( void ). Nota La difer\u00e8ncia per tant entre un procediment i una funci\u00f3 \u00e9s que la segona torna un valor, mentre que el primer no. Per\u00f2 en PL/pgSQL nom\u00e9s hi ha funcions. La sintaxi general (i en principi per a qualsevol llenguatge) de la instrucci\u00f3 de creaci\u00f3 de funcions \u00e9s la seg\u00fcent: CREATE [OR REPLACE] FUNCTION nom_funci\u00f3 [(llista_par\u00e0metres)] RETURNS tipus_del_valor_tornat AS ' instruccions ' LANGUAGE llenguatge; on el llenguatge potser un dels definits (SQL, PL/pgSQL, ...). El cos de la funci\u00f3 pot anar entre cometes simples, o entre un separador que comence i acabe per $ (per exemple $cos$ ) i que ha de ser igual al principi i al final, com veurem en un exemple m\u00e9s avant. Concretament, en el cas de PL/pgSQL, podem refinar un poc m\u00e9s la sintaxi CREATE [OR REPLACE] FUNCTION nom_funci\u00f3 [(llista_par\u00e0metres)] RETURNS tipus_del_valor_tornat AS ' [DECLARE declaraci\u00f3 de variables] BEGIN instruccions RETURN expressi\u00f3 END; ' LANGUAGE plpgsql; Si la funci\u00f3 torna un valor (i per tant l'hem declarada com a que retorna un valor), la instrucci\u00f3 que ens permet retornar el valor \u00e9s RETURN Per exemple, anem a crear una funci\u00f3 que passe de pessetes a euros. Ho podem fer sobre la Base de Dades geo_999x : CREATE FUNCTION EUROS(n int4) RETURNS numeric AS ' BEGIN RETURN ROUND(n/166.386,2); END; ' LANGUAGE plpgsql; SELECT euros(1000); Els tipus de dades de tornada pot ser qualsevol, fins i tot un creat per l'usuari. I si volem que torne m\u00e9s d'un valor, podr\u00edem crear un tipus compost que abarque els valors que volem que torne. Tenim la possibilitat de posar noms als par\u00e0metres (en el cas anterior n), o no, i aleshores la manera de fer-los refer\u00e8ncia \u00e9s per mig de $1 per al primer par\u00e0metre, $2 per al segon, ... Aix\u00ed la mateixa funci\u00f3, sense gastar nom de par\u00e0metre quedaria: CREATE OR REPLACE FUNCTION EUROS2(int4) RETURNS numeric AS ' BEGIN RETURN ROUND($1/166.386,2); END; ' LANGUAGE plpgsql; Anem a veure un altre exemple: una funci\u00f3 que puga convertir una latitud en format text al tipus de dades que ens vam crear en el tema 6, part 3, el tipus lat . Les instruccions estan en el punt 0 (Nota inicial) I ara anem a fer la funci\u00f3 que passa de tipus Text a tipus lat : CREATE OR REPLACE FUNCTION text_a_lat(text) RETURNS lat as $COS$ DECLARE aux lat; BEGIN IF $1 IS NOT NULL THEN aux.g := SUBSTR($1,1,STRPOS($1,'\u00ba')-1); aux.m := SUBSTR($1, STRPOS($1,'\u00ba')+1, STRPOS($1,'''') - STRPOS($1,'\u00ba')-1); aux.s := SUBSTR($1, STRPOS($1,'''')+1, STRPOS($1,'\"') - STRPOS($1,'''')-1); aux.h := SUBSTR($1,STRPOS($1,'\"')+1); ELSE aux := (NULL,NULL,NULL,NULL); END IF; RETURN aux; END; $COS$ LANGUAGE plpgsql; Hem posat $COS$ per a delimitar el cos de la funci\u00f3, per evitar problemes amb les moltes cometes que hi ha. I quan busquem la cometa, doncs en posem 4: la primera i l'\u00faltima s\u00f3n obligat\u00f2ries i delimiten la constant alfanum\u00e8rica. I al mig en posem 2 m\u00e9s per a marcar la cometa. Podem provar a veure si va b\u00e9: SELECT nom,latitud,text_a_lat(latitud),nom_c FROM POBLACIONS; Si la funci\u00f3 va b\u00e9, fins i tot la podr\u00edem utilitzar per omplir la taula POBLACIONS3 (est\u00e0 creada en el punt 0. Nota inicial ), que l'hav\u00edem creada amb el tipus lat (ens convindria eliminar primer les possibles files que hi hagen creades). DELETE FROM POBLACIONS3; INSERT INTO POBLACIONS3 SELECT nom,text_a_lat(latitud),nom_c FROM POBLACIONS; La funci\u00f3 inversa sembla m\u00e9s f\u00e0cil. L'\u00fanic problema, en tot cas, \u00e9s controlar que minuts i segons sempre siguen de dues xifres. I en tot cas llevar espais en blanc que queden pel mig. I haurem d'anar amb compte amb la cometa. Nota En les pr\u00e0ctiques seg\u00fcents en moltes ocasions es diu \"traure per pantalla\". I s\u00f3n funcions que no tenen par\u00e0metre ni tornen cap valor. Encara que a\u00e7\u00f2 no ser\u00e0 el normal en PostgreSQL, per a practicar pot anar b\u00e9. La manera de crear aquestes funcions \u00e9s com en el seg\u00fcent exemple, en el qual creem una funci\u00f3 que trau per pantalla el n\u00famero PI: CREATE OR REPLACE FUNCTION traure_pi() RETURNS void as $COS$ begin raise notice 'El n\u00famero PI \u00e9s: %',PI(); end; $COS$ LANGUAGE 'plpgsql'; En aquesta ocasi\u00f3 hem posat moltes paraules en min\u00fascules, per a demostrar que no importen maj\u00fascules i min\u00fascules. El resultat, si \u00e9s que ho fem des de DBeaver, el veurem fent una altra consulta SQL posant SELECT traure_pi(); i el resultat el veur\u00edem en la pestanya Output , ja que hem provocat traure un missatge. Com veieu estem utilitzant la sent\u00e8ncia RAISE NOTICE , que la veurem millor en la pregunta 7 d'aquest tema, per\u00f2 que ja podem avan\u00e7ar que el que fa \u00e9s traure una l\u00ednia en la pestanya de missatges amb el comen\u00e7ament NOTICE: . Posarem entre cometes simples el text que volem mostrar, i per a traure el contingut d'una variable, posarem entre les cometes un % , i al final, separat per coma la variable de la qual volem mostrar el contingut. Podem posar m\u00e9s d'un %, i al final haurem de posar (separades per comes) tantes variables o expressions com % hem posat entre cometes. Ho veurem millor en els seg\u00fcents exemples. Un altre exemple, tamb\u00e9 d'una funci\u00f3 que no torna res, sin\u00f3 que \"trau per pantalla\" els n\u00fameros del 1 al 10: CREATE OR REPLACE FUNCTION deu() RETURNS VOID as $COS$ BEGIN FOR i IN 1..10 LOOP RAISE NOTICE '%',i; END LOOP; END; $COS$ LANGUAGE 'plpgsql'; Quan l'executem: SELECT deu(); Ens eixir\u00e0 aquest resultat en la pestanya de Output: Una variant seria traure els n\u00fameros del 1 al 10 i el seu doble. Observeu com posem 2 vegades % , i despr\u00e9s posem 2 coses a mostrar, separades per comes: i, i*2 CREATE OR REPLACE FUNCTION deu_doble() RETURNS VOID as $COS$ BEGIN FOR i IN 1..10 LOOP RAISE NOTICE 'N\u00famero: %. Doble: %',i,i*2; END LOOP; END; $COS$ LANGUAGE 'plpgsql'; SELECT deu_doble();","title":"5. Funcions"},{"location":"5_funcions/#exercicis","text":"En la Base de Dades geo_grup_9999x : Ex_1 - Crea una funci\u00f3 anomenada DEU_ Q , que traga els n\u00fameros del 1 al 10 i els seus quadrats . (Utilitza RAISE NOTICE ). Ex_2 - Fes una altra funci\u00f3, IMP , que traga per pantalla els n\u00fameros imparells del 1 al 50. (Utilitza RAISE NOTICE ). Ex_3 - Fes una funci\u00f3 anomenada TAULA_MULT , per a que traga la taula de multiplicar del par\u00e0metre que se li ha de passar. (Utilitza RAISE NOTICE ). Aquest podria ser el seu aspecte, en executar-la: Ex_4 - Fes una funci\u00f3, anomenada MAX2 , que tinga dos par\u00e0metres num\u00e8rics i que torne el m\u00e0xim entre aquestos dos. (Ara ja no s'ha d'utilitzar RAISE NOTICE ). Podeu comprovar el seu funcionament fent per exemple SELECT MAX(5,7); SELECT MAX(15,7) . Sempre ha de mostrar el m\u00e0xim dels dos. Ex_5 - Utilitza l'anterior per a crear MAX3 . Has d'utilitzar obligat\u00f2riament la funci\u00f3 MAX2 Ex_6 - ( Voluntari ) Fes la funci\u00f3 LAT_A_TEXT , tenint en compte que ha de quedar com en la taula POBLACIONS . Segurament la dificultat m\u00e9s gran ser\u00e0 aconseguir que apareguen les cometes despr\u00e9s dels minuts i dels segons. Llicenciat sota la Llic\u00e8ncia Creative Commons Reconeixement NoComercial CompartirIgual 3.0","title":"Exercicis"},{"location":"6_utilitzaci_de_cursors/","text":"6. Utilitzaci\u00f3 de cursors Un cursor \u00e9s una variable que ens permet despla\u00e7ar-nos per les files d\u2019una consulta de SQL. Hi ha dos tipus de cursors, els expl\u00edcits i els impl\u00edcits . Els expl\u00edcits s'han de declarar expressament en la zona de declaracions. Els impl\u00edcits no, seran \u00fanicament una sent\u00e8ncia SQL que guarda el resultat en una variable. Porten impl\u00edcita tota la mec\u00e0nica dels cursors (declarar, obrir, utilitzar, tancar) que haurem de fer en els expl\u00edcits. CURSORS IMPL\u00cdCITS Consistiran en una sent\u00e8ncia SQL dins d'un procediment o funci\u00f3 PL/pgSQL. Han de tornar nom\u00e9s un valor ( nom\u00e9s una fila ), i es guardaran en una variable per mig del INTO de la sent\u00e8ncia SQL. Per exemple, la seg\u00fcent funci\u00f3 tornar\u00e0 el n\u00famero de poblacions. CREATE FUNCTION quantes() RETURNS INTEGER AS ' DECLARE N INTEGER; BEGIN SELECT COUNT(*) INTO N FROM POBLACIONS; RETURN N; END; ' LANGUAGE plpgsql; SELECT quantes(); Per\u00f2 ara ho fa per l'eixida normal CURSORS EXPL\u00cdCITS Aquestos cursors s'han de declarar, b\u00e9 en la zona de declaracions, b\u00e9 en el moment d'obrir-los, com veurem m\u00e9s avant. I en la zona d\u2019instruccions, primer haurem d\u2019obrir ( OPEN ) el cursor (que \u00e9s quan es far\u00e0 la consulta SQL, guardant-se en una zona de mem\u00f2ria i quedant-se situat el cursor en la primera fila). Despr\u00e9s ens anirem despla\u00e7ant fila a fila per fer un determinat tractament ( FETCH : torna el valor i se situa a la seg\u00fcent fila). Per \u00faltim l\u2019haurem de tancar ( CLOSE ). En la declaraci\u00f3 del cursor seguirem la seg\u00fcent sintaxi: _nom_ CURSOR [_par\u00e0metres_] {FOR | IS} _sent\u00e8ncia_select_ Encara que tamb\u00e9 tenim la possibilitat de definir-lo \u00fanicament com a refcursor (refer\u00e8ncia a cursor), sense dir quina \u00e9s la sent\u00e8ncia select. Aleshores l'haurem de definir en el moment d'obrir-lo. Tamb\u00e9 tenim la possibilitat de passar-li un par\u00e0metre. Ac\u00ed tenim alguns exemples de definici\u00f3 de cursors: DECLARE cur1 refcursor; cur2 CURSOR FOR SELECT nom,altura FROM POBLACIONS; cur3 CURSOR(p1 varchar) FOR SELECT nom,altura FROM POBLACIONS WHERE nom=p1; La manera d'obrir-lo dep\u00e8n de la manera com s'havia declarat. Si nom\u00e9s s'havia posat refcursor s'haur\u00e0 de col\u00b7locar la consulta. Si tenia par\u00e0metres s'hauran de posar entre par\u00e8ntesi. Aquesta seria una manera d'obrir els 3 cursors definits anteriorment: BEGIN OPEN cur1 FOR SELECT * FROM POBLACIONS; OPEN cur2; OPEN cur3('Vistabella'); .... END; Hi ha una altra manera d'obrir els cursors definits com a refcursor , que permet especificar la consulta totalment en temps d'execuci\u00f3. Ac\u00ed en tenim un exemple: s := 'SELECT nom FROM ' || $1; OPEN cur1 FOR EXECUTE s; on la taula consultada ve donada com a par\u00e0metre de la funci\u00f3. Per accedir als distints camps de les successives files del cursor ho farem per mig de la sent\u00e8ncia FETCH cur INTO var1 [, var2, ...] i aleshores tindrem els valors disponibles en les variables var1 (, var2, ...) que estaran pr\u00e8viament declarades del mateix tipus. Aix\u00ed en l'exemple de dalt, tenim que el cursor cur2 est\u00e0 definit en base a una sent\u00e8ncia SQL que torna dues columnes ( nom i altura ). La sent\u00e8ncia hauria de ser FETCH cur2 INTO v_nom, v_altura on v_nom i v_altura serien respectivament de tipus varchar i numeric Tamb\u00e9 podr\u00edem haver definir una variable de tipus RECORD . En aquest exemple suposem que la variable f \u00e9s de tipus RECORD FETCH cur2 INTO f Despr\u00e9s, per a accedir a un camp, posarem f. nom_camp . Per a tancar el cursor utilitzarem la sent\u00e8ncia CLOSE . L'habitual ser\u00e0 rec\u00f3rrer tot el cursor. El seg\u00fcent exemple trau tots els noms de les poblacions d'una comarca introdu\u00efda com a par\u00e0metre de la funci\u00f3, utilitzant un cursor: CREATE FUNCTION pobl_com(text) RETURNS void AS $cos$ DECLARE v_nom VARCHAR; cur CURSOR FOR SELECT nom FROM POBLACIONS WHERE nom_c = $1 ORDER BY nom; BEGIN OPEN cur; FETCH cur INTO v_nom; WHILE v_nom IS NOT NULL LOOP RAISE NOTICE '%',v_nom; FETCH cur INTO v_nom; END LOOP; CLOSE cur; END; $cos$ LANGUAGE plpgsql; La manera d'utilitzar aquesta funci\u00f3 ser\u00e0: SELECT pobl_com('Plana Alta'); Per a aquestes ocasions en les quals hem de rec\u00f3rrer totalment un cursor, tenim una variant del FOR que ens ser\u00e0 molt \u00fatil. FOR var_fila IN sent\u00e8ncia_select LOOP on var_fila \u00e9s una variable de tipus RECORD , i que anir\u00e0 agafant els valors de les diferents files (fixeu-vos que s'ha de declarar, en contra de les variables comptador d'un bucle FOR normal). Hem d'observar que en el cas del bucle FOR hem de declarar la sent\u00e8ncia SELECT en el mateix moment de crear el FOR, \u00e9s a dir, no podem utilitzar un cursor definit en la zona de declaracions. Quan utilitzem el bucle FOR per a rec\u00f3rrer un cursor no caldr\u00e0 fer l'acci\u00f3 d'obrir, ni de situar-nos al seg\u00fcent, ni de tancar, ja que es fan de forma impl\u00edcita en el bucle. Reconstru\u00efm l'exemple anterior: CREATE FUNCTION pobl_com_2(text) RETURNS void AS $cos$ DECLARE f RECORD; BEGIN FOR f IN SELECT nom FROM POBLACIONS WHERE nom_c = $1 ORDER BY nom LOOP RAISE NOTICE '%',f.nom; END LOOP; END; $cos$ LANGUAGE plpgsql; Si volgu\u00e9rem construir la sent\u00e8ncia SELECT en temps d'execuci\u00f3, posar\u00edem EXECUTE, encara que a\u00e7\u00f2 potser siga massa avan\u00e7at per a aquest curs: FOR f IN EXECUTE 'SELECT nom FROM ' || $1 LOOP Anem a veure un exemple. Volem calcular la MEDIANA de l'altura de les poblacions. La mediana es defineix com el valor que est\u00e0 al mig de tots si el n\u00famero d\u2019elements \u00e9s imparell (1, 2, 3 , 4, 10), i com la mitjana entre els dos valors centrals si el n\u00famero \u00e9s parell (1, 2, 3 , 4 , 10, 20) -> 3\u20195 , tenint en compte sempre que han d'estar ordenats. \u00c9s suficient amb que entengueu el seu funcionament. CREATE OR REPLACE FUNCTION MEDIANA() RETURNS NUMERIC AS $cos$ DECLARE cur CURSOR FOR SELECT altura FROM POBLACIONS ORDER BY altura; aux INT2; aux1 INT2; i INT2; n INT2; n1 INT2; BEGIN OPEN cur; SELECT COUNT(altura) INTO n FROM POBLACIONS; IF MOD(n,2) = 0 THEN n1 := n; ELSE n1 := n+1; END IF; FOR i IN 1..n1/2 LOOP FETCH cur INTO aux; END LOOP; IF MOD(n,2) = 0 THEN FETCH cur INTO aux1; aux := (aux + aux1) / 2; END IF; RETURN aux; END; $cos$ LANGUAGE plpgsql; SELECT MEDIANA(); Exercicis Ex_7 - Fes una funci\u00f3 anomenada POBLACIONS_ALTES que accepte 2 par\u00e0metres, el primer de tipus text que ser\u00e0 una comarca, i el segon num\u00e8ric que ser\u00e0 una altura. Ha de traure les poblacions de la comarca del primer par\u00e0metre que s\u00f3n m\u00e9s altes que el segon par\u00e0metre. Mostrarem el nom de la poblaci\u00f3 i l'altura. Aquest podria ser el resultat en executar-se: Ex_8 - Fes una funci\u00f3 anomenada COMARQUES_NUMPOBLES sense par\u00e0metres que traga per pantalla les comarques ordenades alfab\u00e8ticament amb el n\u00famero de pobles de cadascuna Ex_9 - Fes una funci\u00f3 anomenada COMARQUES_NUMPOBLES_NUMINSTITUTS sense par\u00e0metres que traga per pantalla les comarques ordenades alfab\u00e8ticament amb el n\u00famero de pobles de cadascuna i el n\u00famero d'instituts. En la consulta tindrem dos dificultats: Hem d'agafar totes les poblacions, fins i tot les que no tenen institut Com que hem d'accedir als instituts, per a comptar els pobles haurem de comptar els pobles distints , i aix\u00ed si un poble t\u00e9 m\u00e9s d'un institut, no comptar-lo m\u00e9s d'una vegada Ex_10 - Fes una funci\u00f3 anomenada NUM_HABITANTS_COMARCA que accepte un par\u00e0metre de tipus text, i torne el n\u00famero d'habitants d'eixa comarca Ex_11 - Fer la funci\u00f3 COMARQUES_NUMHABITANTS sense par\u00e0metres per a traure per pantalla totes les comarques i el n\u00famero d'habitants. En la consulta has d'utilitzar obligat\u00f2riament la funci\u00f3 anterior Llicenciat sota la Llic\u00e8ncia Creative Commons Reconeixement NoComercial CompartirIgual 3.0","title":"6. Utilitzaci\u00f3 de cursors"},{"location":"6_utilitzaci_de_cursors/#6-utilitzacio-de-cursors","text":"Un cursor \u00e9s una variable que ens permet despla\u00e7ar-nos per les files d\u2019una consulta de SQL. Hi ha dos tipus de cursors, els expl\u00edcits i els impl\u00edcits . Els expl\u00edcits s'han de declarar expressament en la zona de declaracions. Els impl\u00edcits no, seran \u00fanicament una sent\u00e8ncia SQL que guarda el resultat en una variable. Porten impl\u00edcita tota la mec\u00e0nica dels cursors (declarar, obrir, utilitzar, tancar) que haurem de fer en els expl\u00edcits. CURSORS IMPL\u00cdCITS Consistiran en una sent\u00e8ncia SQL dins d'un procediment o funci\u00f3 PL/pgSQL. Han de tornar nom\u00e9s un valor ( nom\u00e9s una fila ), i es guardaran en una variable per mig del INTO de la sent\u00e8ncia SQL. Per exemple, la seg\u00fcent funci\u00f3 tornar\u00e0 el n\u00famero de poblacions. CREATE FUNCTION quantes() RETURNS INTEGER AS ' DECLARE N INTEGER; BEGIN SELECT COUNT(*) INTO N FROM POBLACIONS; RETURN N; END; ' LANGUAGE plpgsql; SELECT quantes(); Per\u00f2 ara ho fa per l'eixida normal CURSORS EXPL\u00cdCITS Aquestos cursors s'han de declarar, b\u00e9 en la zona de declaracions, b\u00e9 en el moment d'obrir-los, com veurem m\u00e9s avant. I en la zona d\u2019instruccions, primer haurem d\u2019obrir ( OPEN ) el cursor (que \u00e9s quan es far\u00e0 la consulta SQL, guardant-se en una zona de mem\u00f2ria i quedant-se situat el cursor en la primera fila). Despr\u00e9s ens anirem despla\u00e7ant fila a fila per fer un determinat tractament ( FETCH : torna el valor i se situa a la seg\u00fcent fila). Per \u00faltim l\u2019haurem de tancar ( CLOSE ). En la declaraci\u00f3 del cursor seguirem la seg\u00fcent sintaxi: _nom_ CURSOR [_par\u00e0metres_] {FOR | IS} _sent\u00e8ncia_select_ Encara que tamb\u00e9 tenim la possibilitat de definir-lo \u00fanicament com a refcursor (refer\u00e8ncia a cursor), sense dir quina \u00e9s la sent\u00e8ncia select. Aleshores l'haurem de definir en el moment d'obrir-lo. Tamb\u00e9 tenim la possibilitat de passar-li un par\u00e0metre. Ac\u00ed tenim alguns exemples de definici\u00f3 de cursors: DECLARE cur1 refcursor; cur2 CURSOR FOR SELECT nom,altura FROM POBLACIONS; cur3 CURSOR(p1 varchar) FOR SELECT nom,altura FROM POBLACIONS WHERE nom=p1; La manera d'obrir-lo dep\u00e8n de la manera com s'havia declarat. Si nom\u00e9s s'havia posat refcursor s'haur\u00e0 de col\u00b7locar la consulta. Si tenia par\u00e0metres s'hauran de posar entre par\u00e8ntesi. Aquesta seria una manera d'obrir els 3 cursors definits anteriorment: BEGIN OPEN cur1 FOR SELECT * FROM POBLACIONS; OPEN cur2; OPEN cur3('Vistabella'); .... END; Hi ha una altra manera d'obrir els cursors definits com a refcursor , que permet especificar la consulta totalment en temps d'execuci\u00f3. Ac\u00ed en tenim un exemple: s := 'SELECT nom FROM ' || $1; OPEN cur1 FOR EXECUTE s; on la taula consultada ve donada com a par\u00e0metre de la funci\u00f3. Per accedir als distints camps de les successives files del cursor ho farem per mig de la sent\u00e8ncia FETCH cur INTO var1 [, var2, ...] i aleshores tindrem els valors disponibles en les variables var1 (, var2, ...) que estaran pr\u00e8viament declarades del mateix tipus. Aix\u00ed en l'exemple de dalt, tenim que el cursor cur2 est\u00e0 definit en base a una sent\u00e8ncia SQL que torna dues columnes ( nom i altura ). La sent\u00e8ncia hauria de ser FETCH cur2 INTO v_nom, v_altura on v_nom i v_altura serien respectivament de tipus varchar i numeric Tamb\u00e9 podr\u00edem haver definir una variable de tipus RECORD . En aquest exemple suposem que la variable f \u00e9s de tipus RECORD FETCH cur2 INTO f Despr\u00e9s, per a accedir a un camp, posarem f. nom_camp . Per a tancar el cursor utilitzarem la sent\u00e8ncia CLOSE . L'habitual ser\u00e0 rec\u00f3rrer tot el cursor. El seg\u00fcent exemple trau tots els noms de les poblacions d'una comarca introdu\u00efda com a par\u00e0metre de la funci\u00f3, utilitzant un cursor: CREATE FUNCTION pobl_com(text) RETURNS void AS $cos$ DECLARE v_nom VARCHAR; cur CURSOR FOR SELECT nom FROM POBLACIONS WHERE nom_c = $1 ORDER BY nom; BEGIN OPEN cur; FETCH cur INTO v_nom; WHILE v_nom IS NOT NULL LOOP RAISE NOTICE '%',v_nom; FETCH cur INTO v_nom; END LOOP; CLOSE cur; END; $cos$ LANGUAGE plpgsql; La manera d'utilitzar aquesta funci\u00f3 ser\u00e0: SELECT pobl_com('Plana Alta'); Per a aquestes ocasions en les quals hem de rec\u00f3rrer totalment un cursor, tenim una variant del FOR que ens ser\u00e0 molt \u00fatil. FOR var_fila IN sent\u00e8ncia_select LOOP on var_fila \u00e9s una variable de tipus RECORD , i que anir\u00e0 agafant els valors de les diferents files (fixeu-vos que s'ha de declarar, en contra de les variables comptador d'un bucle FOR normal). Hem d'observar que en el cas del bucle FOR hem de declarar la sent\u00e8ncia SELECT en el mateix moment de crear el FOR, \u00e9s a dir, no podem utilitzar un cursor definit en la zona de declaracions. Quan utilitzem el bucle FOR per a rec\u00f3rrer un cursor no caldr\u00e0 fer l'acci\u00f3 d'obrir, ni de situar-nos al seg\u00fcent, ni de tancar, ja que es fan de forma impl\u00edcita en el bucle. Reconstru\u00efm l'exemple anterior: CREATE FUNCTION pobl_com_2(text) RETURNS void AS $cos$ DECLARE f RECORD; BEGIN FOR f IN SELECT nom FROM POBLACIONS WHERE nom_c = $1 ORDER BY nom LOOP RAISE NOTICE '%',f.nom; END LOOP; END; $cos$ LANGUAGE plpgsql; Si volgu\u00e9rem construir la sent\u00e8ncia SELECT en temps d'execuci\u00f3, posar\u00edem EXECUTE, encara que a\u00e7\u00f2 potser siga massa avan\u00e7at per a aquest curs: FOR f IN EXECUTE 'SELECT nom FROM ' || $1 LOOP Anem a veure un exemple. Volem calcular la MEDIANA de l'altura de les poblacions. La mediana es defineix com el valor que est\u00e0 al mig de tots si el n\u00famero d\u2019elements \u00e9s imparell (1, 2, 3 , 4, 10), i com la mitjana entre els dos valors centrals si el n\u00famero \u00e9s parell (1, 2, 3 , 4 , 10, 20) -> 3\u20195 , tenint en compte sempre que han d'estar ordenats. \u00c9s suficient amb que entengueu el seu funcionament. CREATE OR REPLACE FUNCTION MEDIANA() RETURNS NUMERIC AS $cos$ DECLARE cur CURSOR FOR SELECT altura FROM POBLACIONS ORDER BY altura; aux INT2; aux1 INT2; i INT2; n INT2; n1 INT2; BEGIN OPEN cur; SELECT COUNT(altura) INTO n FROM POBLACIONS; IF MOD(n,2) = 0 THEN n1 := n; ELSE n1 := n+1; END IF; FOR i IN 1..n1/2 LOOP FETCH cur INTO aux; END LOOP; IF MOD(n,2) = 0 THEN FETCH cur INTO aux1; aux := (aux + aux1) / 2; END IF; RETURN aux; END; $cos$ LANGUAGE plpgsql; SELECT MEDIANA();","title":"6. Utilitzaci\u00f3 de cursors"},{"location":"6_utilitzaci_de_cursors/#exercicis","text":"Ex_7 - Fes una funci\u00f3 anomenada POBLACIONS_ALTES que accepte 2 par\u00e0metres, el primer de tipus text que ser\u00e0 una comarca, i el segon num\u00e8ric que ser\u00e0 una altura. Ha de traure les poblacions de la comarca del primer par\u00e0metre que s\u00f3n m\u00e9s altes que el segon par\u00e0metre. Mostrarem el nom de la poblaci\u00f3 i l'altura. Aquest podria ser el resultat en executar-se: Ex_8 - Fes una funci\u00f3 anomenada COMARQUES_NUMPOBLES sense par\u00e0metres que traga per pantalla les comarques ordenades alfab\u00e8ticament amb el n\u00famero de pobles de cadascuna Ex_9 - Fes una funci\u00f3 anomenada COMARQUES_NUMPOBLES_NUMINSTITUTS sense par\u00e0metres que traga per pantalla les comarques ordenades alfab\u00e8ticament amb el n\u00famero de pobles de cadascuna i el n\u00famero d'instituts. En la consulta tindrem dos dificultats: Hem d'agafar totes les poblacions, fins i tot les que no tenen institut Com que hem d'accedir als instituts, per a comptar els pobles haurem de comptar els pobles distints , i aix\u00ed si un poble t\u00e9 m\u00e9s d'un institut, no comptar-lo m\u00e9s d'una vegada Ex_10 - Fes una funci\u00f3 anomenada NUM_HABITANTS_COMARCA que accepte un par\u00e0metre de tipus text, i torne el n\u00famero d'habitants d'eixa comarca Ex_11 - Fer la funci\u00f3 COMARQUES_NUMHABITANTS sense par\u00e0metres per a traure per pantalla totes les comarques i el n\u00famero d'habitants. En la consulta has d'utilitzar obligat\u00f2riament la funci\u00f3 anterior Llicenciat sota la Llic\u00e8ncia Creative Commons Reconeixement NoComercial CompartirIgual 3.0","title":"Exercicis"},{"location":"7_missatges_i_excepcions/","text":"7. Missatges i excepcions Al llarg dels exemples i exercicis que hem fet fins ara, ens ha vingut molt b\u00e9 traure algun missatge, per veure com anava l'execuci\u00f3 de les funcions. El que feem era provocar un aconteixement, en aquest cas una not\u00edcia, un av\u00eds. Podem utilitzar la mateixa sent\u00e8ncia per a provocar tamb\u00e9 un error, amb el conseq\u00fcent avortament de l'execuci\u00f3 de la funci\u00f3. Anem a veure-ho amb m\u00e9s detall. RAISE nivell 'format' [,variable1[,...]]; En nivell posarem un dels seg\u00fcents: DEBUG , LOG , INFO , NOTICE , WARNING o EXCEPTION , on la major part nom\u00e9s donen un av\u00eds (amb l'encap\u00e7alament corresponent). Per\u00f2 EXCEPTION a m\u00e9s de traure l'av\u00eds avorta l'execuci\u00f3. En format posarem una cadena amb el comentari que vulguem. Podrem posar % les vegades que vulguem, i se substituiran pel contingut de les variables que tinguem a continuaci\u00f3. Aix\u00ed, per exemple, creem una funci\u00f3 de salutaci\u00f3: CREATE OR REPLACE FUNCTION SALUTACIO() RETURNS VOID as $COS$ DECLARE s1 text := 'Joanet'; s2 date := CURRENT_DATE; BEGIN RAISE NOTICE 'Hola'; RAISE NOTICE 'Hola, %. Avui \u00e9s %',s1,s2; RAISE NOTICE 'Qu\u00e8 tal?'; END; $COS$ LANGUAGE 'plpgsql'; Si ara fem: SELECT SALUTACIO(); Provocar\u00e0 la seg\u00fcent eixida (en la pestanya Output ): Hola, Joanet. Avui es 2022-02-14 Qu\u00e8 tal? En canvi si la canviem el primer RAISE NOTICE per un RAISE EXCEPTION , i posem un altre RAISE NOTICE davant: CREATE OR REPLACE FUNCTION SALUTACIO() RETURNS VOID as $COS$ DECLARE s1 text := 'Joanet'; s2 date := CURRENT_DATE; BEGIN RAISE NOTICE 'Hola'; RAISE EXCEPTION 'Hola, %. Avui \u00e9s %',s1,s2; RAISE NOTICE 'Qu\u00e8 tal?'; END; $COS$ LANGUAGE 'plpgsql'; Nom\u00e9s trauria el primer Hola, i despr\u00e9s donaria un error amb el missatge que li hem posat: I no trauria aix\u00f2 de Qu\u00e8 tal? , perqu\u00e8 ja s'ha avortat la funci\u00f3. \u00c9s a dir, hem provocat nosaltres l'error Llicenciat sota la Llic\u00e8ncia Creative Commons Reconeixement NoComercial CompartirIgual 3.0","title":"7. Missatges"},{"location":"7_missatges_i_excepcions/#7-missatges-i-excepcions","text":"Al llarg dels exemples i exercicis que hem fet fins ara, ens ha vingut molt b\u00e9 traure algun missatge, per veure com anava l'execuci\u00f3 de les funcions. El que feem era provocar un aconteixement, en aquest cas una not\u00edcia, un av\u00eds. Podem utilitzar la mateixa sent\u00e8ncia per a provocar tamb\u00e9 un error, amb el conseq\u00fcent avortament de l'execuci\u00f3 de la funci\u00f3. Anem a veure-ho amb m\u00e9s detall. RAISE nivell 'format' [,variable1[,...]]; En nivell posarem un dels seg\u00fcents: DEBUG , LOG , INFO , NOTICE , WARNING o EXCEPTION , on la major part nom\u00e9s donen un av\u00eds (amb l'encap\u00e7alament corresponent). Per\u00f2 EXCEPTION a m\u00e9s de traure l'av\u00eds avorta l'execuci\u00f3. En format posarem una cadena amb el comentari que vulguem. Podrem posar % les vegades que vulguem, i se substituiran pel contingut de les variables que tinguem a continuaci\u00f3. Aix\u00ed, per exemple, creem una funci\u00f3 de salutaci\u00f3: CREATE OR REPLACE FUNCTION SALUTACIO() RETURNS VOID as $COS$ DECLARE s1 text := 'Joanet'; s2 date := CURRENT_DATE; BEGIN RAISE NOTICE 'Hola'; RAISE NOTICE 'Hola, %. Avui \u00e9s %',s1,s2; RAISE NOTICE 'Qu\u00e8 tal?'; END; $COS$ LANGUAGE 'plpgsql'; Si ara fem: SELECT SALUTACIO(); Provocar\u00e0 la seg\u00fcent eixida (en la pestanya Output ): Hola, Joanet. Avui es 2022-02-14 Qu\u00e8 tal? En canvi si la canviem el primer RAISE NOTICE per un RAISE EXCEPTION , i posem un altre RAISE NOTICE davant: CREATE OR REPLACE FUNCTION SALUTACIO() RETURNS VOID as $COS$ DECLARE s1 text := 'Joanet'; s2 date := CURRENT_DATE; BEGIN RAISE NOTICE 'Hola'; RAISE EXCEPTION 'Hola, %. Avui \u00e9s %',s1,s2; RAISE NOTICE 'Qu\u00e8 tal?'; END; $COS$ LANGUAGE 'plpgsql'; Nom\u00e9s trauria el primer Hola, i despr\u00e9s donaria un error amb el missatge que li hem posat: I no trauria aix\u00f2 de Qu\u00e8 tal? , perqu\u00e8 ja s'ha avortat la funci\u00f3. \u00c9s a dir, hem provocat nosaltres l'error Llicenciat sota la Llic\u00e8ncia Creative Commons Reconeixement NoComercial CompartirIgual 3.0","title":"7. Missatges i excepcions"},{"location":"8_triggers/","text":"8. Triggers Un TRIGGER o disparador \u00e9s un procediment que se dispara quan s\u2019acompleix una determinada condici\u00f3 que afecta a la Base de Dades: quan s\u2019actualitza una o m\u00e9s d\u2019una fila d\u2019una determinada taula. En el moment de crear el trigger especificarem una funci\u00f3 que s'executar\u00e0 quan es produesca l'event. Aquesta funci\u00f3 pot estar escrita en qualsevol llenguatge de programaci\u00f3 instal\u00b7lat, i ha de tornar un valor especial: trigger . Juguem per tant a dues bandes. Primer amb la funci\u00f3 que s'executar\u00e0, i quan aquesta estiga creada, el trigger pr\u00f2piament dit. La sintaxi de creaci\u00f3 del trigger \u00e9s: CREATE TRIGGER nom_trig {BEFORE | AFTER} {INSERT | DELETE | UPDATE} [OR {INSERT | DELETE |UPDATE} ...] ON nom_taula [FOR EACH {ROW | STATEMENT}] EXECUTE PROCEDURE nom_funci\u00f3 ([par\u00e0metres]); Lamentablement no tenim l\u2019opci\u00f3 OR REPLACE , que ens permetria no haver d\u2019esborrar el trigger en cas de voler refer-lo (cosa prou normal). Per tant, en el cas tan habitual de voler refer un trigger , primer l'haurem d'esborrar ( DROP TRIGGER ) i despr\u00e9s tornar a fer-lo, encara que si \u00e9s una modificaci\u00f3 en la funci\u00f3 no cal tocar el trigger . BEFORE o AFTER indiquen quan s\u2019ha d\u2019activar el trigger : abans de produir-se l\u2019acci\u00f3 d\u2019inserir, esborrar o modificar, o despr\u00e9s. INSERT , DELETE o UPDATE indiquen quina acci\u00f3 d\u2019actualitzaci\u00f3 de la taula provoca (o pot provocar) el trigger . Una actualitzaci\u00f3 pot afectar m\u00e9s d\u2019una fila. Aleshores ens plantegem si s\u2019ha de disparar el trigger per a cada actualitzaci\u00f3 de cada fila, o si nom\u00e9s una vegada (abans o despr\u00e9s d\u2019actualitzar). Ho podrem especificar per mig de FOR EACH ROW o FOR EACH STATEMENT . L'opci\u00f3 per defecte \u00e9s la segona. Suposem que volem activar un disparador sempre abans d\u2019inserir sobre la taula T1 , per a cada fila, per si la introducci\u00f3 no f\u00f3ra correcta: CREATE TRIGGER trigger1 BEFORE INSERT ON T1 FOR EACH ROW EXECUTE PROCEDURE ...; I ara que volem activar un altre despr\u00e9s d\u2019esborrar un conjunt de files (per exemple per a actualitzar una altra taula): CREATE TRIGGER trigger2 AFTER DELETE ON T1 FOR EACH STATEMENT EXECUTE PROCEDURE ...; Anem a parlar ara de la funci\u00f3 que es crida quan es dispara el trigger . \u00c9s una funci\u00f3 especial, escrita en qualsevol llenguatge definit, que com hem comentat abans ha de tornar obligat\u00f2riament un valor TRIGGER . Aquesta funci\u00f3 pot tenir par\u00e0metres, i \u00f2bviament hauran de coincidir aquestos en la definici\u00f3 de la funci\u00f3 i en la definici\u00f3 del trigger . Quan s'arriba a la funci\u00f3, que nosaltres sempre la definirem en PL/pgSQL, s'han definit unes quantes variables especials. Anem a comentar-les: Nom Tipus Descripci\u00f3 NEW RECORD Cont\u00e9 la fila que va a inserir-se o la nova informaci\u00f3, si va a actualitzar-se. OLD RECORD Cont\u00e9 la fila que va a esborrar-se o la informaci\u00f3 vella, si va a actualitzar-se. TG_NAME NAME Cont\u00e9 el nom del trigger que s'ha disparat i ha cridat aquesta funci\u00f3. TG_WHEN TEXT Indica quan actua el trigger, BEFORE o AFTER . TG_LEVEL TEXT Indica de quina manera actua, ROW o STATEMENT . TG_OP TEXT Indica quin event ha provocat el trigger: INSERT , UPDATE o DELETE . TG_RELID OID Cont\u00e9 l'identificador de la taula que ha provocat el trigger (podria ser m\u00e9s d'una). TG_RELNAME TEXT Cont\u00e9 el nom de la taula que ha provocat el trigger. TG_NARGS INTEGER Indica el nombre de par\u00e0metres que se li passen. TG_ARGV[ ] VECTOR de TEXT Vector que cont\u00e9 els par\u00e0metres. Aquesta \u00e9s una relaci\u00f3 de variables prou extensiva. En la pr\u00e0ctica nosaltres nom\u00e9s utilitzarem NEW , OLD i en tot cas TG_OP . Una funci\u00f3 de trigger ha de tornar o b\u00e9 NULL , o b\u00e9 un RECORD , amb la mateixa estructura que la fila de la taula. Depenent del tipus de trigger (BEFORE o AFTER), podeu tornar: Tipus de Trigger Qu\u00e8 ha de tornar la funci\u00f3 de trigger BEFORE INSERT/UPDATE NEW (per modificar la fila) o NULL (per cancel\u00b7lar) BEFORE DELETE OLD (si cal registrar el valor abans d'esborrar) AFTER (cualquier tipus) NULL (perqu\u00e8 l'operaci\u00f3 ja es va executar) Si un trigger de nivell de fila ( for each row ) torna un valor null, no s'efectuaran m\u00e9s operacions (si \u00e9s un delete, que esborra m\u00e9s d'una fila, si la funci\u00f3 torna null, ja no s'intentaran esborrar m\u00e9s files). En canvi, si torna una cosa distinta de null, aleshores es procedir\u00e0 a l'actualitzaci\u00f3 amb aquest valor. Aix\u00ed, per curar en salut, podem fer que l'\u00faltima l\u00ednia de la funci\u00f3 de trigger siga RETURN NEW; A\u00e7\u00f2 pot ser molt \u00fatil, ja que si \u00e9s una inserci\u00f3 o actualitzaci\u00f3 podr\u00edem fins i tot modificar la fila NEW per a que agafe els valors que nosaltres volem (per exemple: NEW.sou := NEW.sou + 500 si estigu\u00e9rem actualitzant el sou d'un empleat). Els valors tornats per una funci\u00f3 trigger de nivell de statement s\u00f3n sempre ignorats, igual que un AFTER de nivell de fila (ja \u00e9s massa tard per actuar), i per tant millor posar que tornen null. Exemple: Modificar valors abans de la inserci\u00f3 (BEFORE INSERT) Si alg\u00fa insereix NULL en nom, el trigger el reempla\u00e7a per 'Desconocido'. CREATE OR REPLACE FUNCTION evitar_nulos() RETURNS TRIGGER AS $$ BEGIN -- Si el campo nombre es NULL, se asigna un valor por defecto IF NEW.nombre IS NULL THEN NEW.nombre := 'Desconocido'; END IF; RETURN NEW; -- Devuelve la fila modificada END; $$ LANGUAGE plpgsql; CREATE TRIGGER trigger_evitar_nulos BEFORE INSERT ON usuarios FOR EACH ROW EXECUTE FUNCTION evitar_nulos(); Exemple: Cancel\u00b7lar una inserci\u00f3 (BEFORE INSERT amb NULL) Si el saldo \u00e9s menor que 0, es cancel\u00b7la la inserci\u00f3 CREATE OR REPLACE FUNCTION bloquear_insercion() RETURNS TRIGGER AS $$ BEGIN IF NEW.saldo < 0 THEN RAISE EXCEPTION 'No se permiten saldos negativos'; RETURN NULL; -- Cancela la inserci\u00f3n END IF; RETURN NEW; END; $$ LANGUAGE plpgsql; CREATE TRIGGER trigger_bloqueo BEFORE INSERT ON cuentas FOR EACH ROW EXECUTE FUNCTION bloquear_insercion(); Anem a veure uns altres exemples en la base de dades geo_grup_9999x : Exemple : impedir que es modifique el nombre d'habitants d'una localitat en m\u00e9s de 50000 persones (augmentant o disminuint). Nom\u00e9s t\u00e9 sentit el control quan es modifique la columna poblacio . No t\u00e9 sentit ni en inserir ni en esborrar una fila. I ens conv\u00e9 abans d\u2019actualitzar, per poder impedir-ho. CREATE FUNCTION val_50000() RETURNS TRIGGER AS $cos$ BEGIN IF abs(NEW.poblacio - OLD.poblacio) > 50000 THEN RAISE EXCEPTION 'Massa difer\u00e8ncia. No pot ser!!'; END IF; RETURN NEW; END; $cos$ LANGUAGE plpgsql; CREATE TRIGGER tr_val_50000 BEFORE UPDATE ON POBLACIONS FOR EACH ROW EXECUTE PROCEDURE val_50000(); Podr\u00edem comprovar el funcionament del trigger actualitzant alguna fila de la taula POBLACIONS: UPDATE POBLACIONS SET poblacio = 1000 WHERE nom='Castell\u00f3 de la Plana'; Com veieu estem intentant actualitzar la poblaci\u00f3 de Castell\u00f3 de la Plana a 1.000 habitants. Com que la poblaci\u00f3 actual \u00e9s de 173.841, hi haur\u00e0 una difer\u00e8ncia de m\u00e9s de 50.000 habitants, i per tant el trigger impedir\u00e0 l'actualitzaci\u00f3: Nota En DBeaver veurem els triggers en la taula a la qual afecten. Mirem un altre exemple : un trigger que actualitza autom\u00e0ticament el nombre d'instituts de la taula PROVINCIES (teniu la sent\u00e8ncia de creaci\u00f3 en la pregunta 0 d'aquest tema) quan s'insereix o s'esborra un institut. Primer s'haur\u00e0 de mirar la prov\u00edncia de l'institut que s'est\u00e0 introduint o esborrant, i despr\u00e9s s'incrementa o decrementa el nombre d'instituts de la prov\u00edncia: CREATE OR REPLACE FUNCTION act_inst() RETURNS TRIGGER AS $cos$ DECLARE aux text; BEGIN IF TG_OP='INSERT' THEN SELECT provincia INTO aux FROM POBLACIONS,COMARQUES WHERE POBLACIONS.nom_c=COMARQUES.nom_c AND POBLACIONS.cod_m = NEW.cod_m; UPDATE PROVINCIES SET instituts = instituts + 1 WHERE provincia = aux; ELSE SELECT provincia INTO aux FROM POBLACIONS,COMARQUES WHERE POBLACIONS.nom_c=COMARQUES.nom_c AND POBLACIONS.cod_m = OLD.cod_m; UPDATE PROVINCIES SET instituts = instituts - 1 WHERE provincia = aux; END IF; RETURN NEW; END; $cos$ LANGUAGE plpgsql; CREATE TRIGGER tr_act_inst AFTER INSERT OR DELETE ON INSTITUTS FOR EACH ROW EXECUTE PROCEDURE act_inst(); Podrem comprovar-ho, per exemple, introduint un nou registre. Abans de l'actualitzaci\u00f3, el contingut de la taula PROVINCIES \u00e9s: Inserim ara el nou institut, corresponent a Castell\u00f3 (el codi del municipi \u00e9s 12040) INSERT INTO INSTITUTS VALUES ('12004299','IES MARJALERIA','CAM\u00cd LA PLANA','S/N',12003,12040); El contingut de la taula PROVINCIES \u00e9s ara: Un \u00faltim exemple per a veure el de FOR EACH STATEMENT . Intentarem fer un trigger per a que actualitze la poblaci\u00f3 de les prov\u00edncies. Ara anem a plantejar-lo de manera que calcule una altra vegada el total de les poblacions. Per tant, segurament \u00e9s millor calcular-ho quantes menys vegades millor; \u00e9s a dir, si es fan unes quantes actualitzacions de les poblacions, doncs calcular al final de totes elles (i no despr\u00e9s de cadascuna). CREATE OR REPLACE FUNCTION act_pobl() RETURNS TRIGGER AS $cos$ BEGIN UPDATE PROVINCIES SET habitants = (SELECT SUM(poblacio) FROM COMARQUES,POBLACIONS WHERE COMARQUES.nom_c=POBLACIONS.nom_c and provincia=PROVINCIES.provincia); RETURN NEW; END; $cos$ LANGUAGE plpgsql; CREATE TRIGGER tr_act_pobl AFTER INSERT OR DELETE OR UPDATE ON POBLACIONS FOR EACH STATEMENT EXECUTE PROCEDURE act_pobl(); Per a poder comprovar el resultat del trigger anem a fer una operaci\u00f3 d'actualitzaci\u00f3. Per exemple anem a incrementar cada poblaci\u00f3 de la comarca de l'Alcalat\u00e9n en 10.000 habitants (recordeu que ja tenim un trigger que impedeix augmentar en m\u00e9s de 50.000). UPDATE POBLACIONS SET poblacio = poblacio + 10000 WHERE nom_c = 'Alcalat\u00e9n'; Com que la comarca t\u00e9 9 pobles, la poblaci\u00f3 de la prov\u00edncia de Castell\u00f3 haur\u00e0 augmentat en 90.000 habitants: No oblidem executar l'operaci\u00f3 de restar 10.000 habitants als pobles de la comarca de l'Alcalat\u00e9n, i llevar l'institut de la Marjaleria, per deixar les coses com estaven (encara que nom\u00e9s s\u00f3n dades de prova molt desactualitzades). UPDATE POBLACIONS SET poblacio = poblacio - 10000 WHERE nom_c = 'Alcalat\u00e9n'; DELETE FROM INSTITUTS WHERE codi = '12004299'; Per esborrar un trigger, utilitzarem la instrucci\u00f3 DROP TRIGGER : DROP TRIGGER nom_trigger ON nom_taula; La modificaci\u00f3 d'un trigger ( ALTER TRIGGER) nom\u00e9s permet canviar el nom d'aquest trigger. Pot ser molt \u00fatil en ocasions desactivar un trigger , de manera que no tinga efecte durant una temporada, i tornar a activar-lo m\u00e9s avant. Est\u00e0 clar que sempre podr\u00edem esborrar-lo i tornar a crear-lo quan fa\u00e7a falta, per\u00f2 ser\u00e0 m\u00e9s c\u00f2moda la desactivaci\u00f3. Aquesta operaci\u00f3 es fa en l' ALTER TABLE de la taula a la qual implica el trigger . ALTER TABLE nom_taula [ENABLE | DISABLE] TRIGGER [nom_trigger | ALL | USER ]; Com es pot comprovar, la sent\u00e8ncia permet activar o desactivar un trigger en concret, o tots els triggers (caldr\u00e0 tenir privilegis de superusuari, ja que a\u00e7\u00f2 inclouria els triggers implicits que fan acomplir les restriccions d'integritat, i aix\u00f2 nom\u00e9s ho podria fer un superusuari), o els triggers d'usuari, que s\u00f3n els que no s\u00f3n per implementar les claus externes. Exercicis En la Base de Dades geo_grup_9999x : Ex_12 - Crear un trigger anomenat TR_ALT_POS que controle que l'altura d'una nova poblaci\u00f3 siga estrictament psitiva. La funci\u00f3 en la qual es basa es pot anomenar ALT_POS . Ex_13 - Modificar l'anterior per a que ho controle tamb\u00e9 quan es tracta d'una modificaci\u00f3. Ex_14 - Crear un trigger anomenat TR_EXT_0_1000 que controle que l'extensi\u00f3 d'un municipi (poblaci\u00f3) estiga obligat\u00f2riament entre 0 i 1000, i ha de ser sempre, tant si s'insereix una nova poblaci\u00f3 com si es modifica. Per\u00f2 en aquesta ocasi\u00f3, en compte de traure un error, el que farem ser\u00e0 modificar aquest valor: si \u00e9s major que 1000, li donarem el valor 1000, i si \u00e9s negatiu li posarem 0. Ho aconseguirem modificant NEW.extensio, i com la funci\u00f3 del trigger torna sempre NEW, doncs agafar\u00e0 el nou valor. Anomeneu a la funci\u00f3 EXT_0_1000 . Ex_15 - VOLUNTARI . En la taula POBLACIONS3 tenim controlat que la latitud introdu\u00efda siga correcta per mig del tipus lat, per\u00f2 no en la taula POBLACIONS, on \u00e9s de tipus VARCHAR(50) i per tant es podria introduir una latitud incorrecta molt f\u00e0cilment. Crea un trigger que controle que quan s'introdueix o es modifica la latitud de POBLACIONS siga correcta. Per a aix\u00f2 Els car\u00e0cters 1 i 2 han de ser els graus , que han d'estar entre 00 i 90 El car\u00e0cter 3 ha de ser \u00ba Els car\u00e0cters 4 i 5 formen els minuts , i han d'estar entre 00 i 59 El car\u00e0cter 6 ha de ser ' Els car\u00e0cters 7 i 8 formen els segons , i han d'estar entre 00 i 59 El car\u00e0cter 9 ha de ser \" El car\u00e0cter 10 ha de ser N o S Si no s'acompleix alguna de les restriccions anteriors, ha d'eixir un error dient que la latitud ha d'estar entre 00\u00ba00'00\"N i 90\u00ba00'00\"N , o entre 00\u00ba00'00\"S i 90\u00ba00'00\"S Llicenciat sota la Llic\u00e8ncia Creative Commons Reconeixement NoComercial CompartirIgual 3.0","title":"8. Triggers"},{"location":"8_triggers/#8-triggers","text":"Un TRIGGER o disparador \u00e9s un procediment que se dispara quan s\u2019acompleix una determinada condici\u00f3 que afecta a la Base de Dades: quan s\u2019actualitza una o m\u00e9s d\u2019una fila d\u2019una determinada taula. En el moment de crear el trigger especificarem una funci\u00f3 que s'executar\u00e0 quan es produesca l'event. Aquesta funci\u00f3 pot estar escrita en qualsevol llenguatge de programaci\u00f3 instal\u00b7lat, i ha de tornar un valor especial: trigger . Juguem per tant a dues bandes. Primer amb la funci\u00f3 que s'executar\u00e0, i quan aquesta estiga creada, el trigger pr\u00f2piament dit. La sintaxi de creaci\u00f3 del trigger \u00e9s: CREATE TRIGGER nom_trig {BEFORE | AFTER} {INSERT | DELETE | UPDATE} [OR {INSERT | DELETE |UPDATE} ...] ON nom_taula [FOR EACH {ROW | STATEMENT}] EXECUTE PROCEDURE nom_funci\u00f3 ([par\u00e0metres]); Lamentablement no tenim l\u2019opci\u00f3 OR REPLACE , que ens permetria no haver d\u2019esborrar el trigger en cas de voler refer-lo (cosa prou normal). Per tant, en el cas tan habitual de voler refer un trigger , primer l'haurem d'esborrar ( DROP TRIGGER ) i despr\u00e9s tornar a fer-lo, encara que si \u00e9s una modificaci\u00f3 en la funci\u00f3 no cal tocar el trigger . BEFORE o AFTER indiquen quan s\u2019ha d\u2019activar el trigger : abans de produir-se l\u2019acci\u00f3 d\u2019inserir, esborrar o modificar, o despr\u00e9s. INSERT , DELETE o UPDATE indiquen quina acci\u00f3 d\u2019actualitzaci\u00f3 de la taula provoca (o pot provocar) el trigger . Una actualitzaci\u00f3 pot afectar m\u00e9s d\u2019una fila. Aleshores ens plantegem si s\u2019ha de disparar el trigger per a cada actualitzaci\u00f3 de cada fila, o si nom\u00e9s una vegada (abans o despr\u00e9s d\u2019actualitzar). Ho podrem especificar per mig de FOR EACH ROW o FOR EACH STATEMENT . L'opci\u00f3 per defecte \u00e9s la segona. Suposem que volem activar un disparador sempre abans d\u2019inserir sobre la taula T1 , per a cada fila, per si la introducci\u00f3 no f\u00f3ra correcta: CREATE TRIGGER trigger1 BEFORE INSERT ON T1 FOR EACH ROW EXECUTE PROCEDURE ...; I ara que volem activar un altre despr\u00e9s d\u2019esborrar un conjunt de files (per exemple per a actualitzar una altra taula): CREATE TRIGGER trigger2 AFTER DELETE ON T1 FOR EACH STATEMENT EXECUTE PROCEDURE ...; Anem a parlar ara de la funci\u00f3 que es crida quan es dispara el trigger . \u00c9s una funci\u00f3 especial, escrita en qualsevol llenguatge definit, que com hem comentat abans ha de tornar obligat\u00f2riament un valor TRIGGER . Aquesta funci\u00f3 pot tenir par\u00e0metres, i \u00f2bviament hauran de coincidir aquestos en la definici\u00f3 de la funci\u00f3 i en la definici\u00f3 del trigger . Quan s'arriba a la funci\u00f3, que nosaltres sempre la definirem en PL/pgSQL, s'han definit unes quantes variables especials. Anem a comentar-les: Nom Tipus Descripci\u00f3 NEW RECORD Cont\u00e9 la fila que va a inserir-se o la nova informaci\u00f3, si va a actualitzar-se. OLD RECORD Cont\u00e9 la fila que va a esborrar-se o la informaci\u00f3 vella, si va a actualitzar-se. TG_NAME NAME Cont\u00e9 el nom del trigger que s'ha disparat i ha cridat aquesta funci\u00f3. TG_WHEN TEXT Indica quan actua el trigger, BEFORE o AFTER . TG_LEVEL TEXT Indica de quina manera actua, ROW o STATEMENT . TG_OP TEXT Indica quin event ha provocat el trigger: INSERT , UPDATE o DELETE . TG_RELID OID Cont\u00e9 l'identificador de la taula que ha provocat el trigger (podria ser m\u00e9s d'una). TG_RELNAME TEXT Cont\u00e9 el nom de la taula que ha provocat el trigger. TG_NARGS INTEGER Indica el nombre de par\u00e0metres que se li passen. TG_ARGV[ ] VECTOR de TEXT Vector que cont\u00e9 els par\u00e0metres. Aquesta \u00e9s una relaci\u00f3 de variables prou extensiva. En la pr\u00e0ctica nosaltres nom\u00e9s utilitzarem NEW , OLD i en tot cas TG_OP . Una funci\u00f3 de trigger ha de tornar o b\u00e9 NULL , o b\u00e9 un RECORD , amb la mateixa estructura que la fila de la taula. Depenent del tipus de trigger (BEFORE o AFTER), podeu tornar: Tipus de Trigger Qu\u00e8 ha de tornar la funci\u00f3 de trigger BEFORE INSERT/UPDATE NEW (per modificar la fila) o NULL (per cancel\u00b7lar) BEFORE DELETE OLD (si cal registrar el valor abans d'esborrar) AFTER (cualquier tipus) NULL (perqu\u00e8 l'operaci\u00f3 ja es va executar) Si un trigger de nivell de fila ( for each row ) torna un valor null, no s'efectuaran m\u00e9s operacions (si \u00e9s un delete, que esborra m\u00e9s d'una fila, si la funci\u00f3 torna null, ja no s'intentaran esborrar m\u00e9s files). En canvi, si torna una cosa distinta de null, aleshores es procedir\u00e0 a l'actualitzaci\u00f3 amb aquest valor. Aix\u00ed, per curar en salut, podem fer que l'\u00faltima l\u00ednia de la funci\u00f3 de trigger siga RETURN NEW; A\u00e7\u00f2 pot ser molt \u00fatil, ja que si \u00e9s una inserci\u00f3 o actualitzaci\u00f3 podr\u00edem fins i tot modificar la fila NEW per a que agafe els valors que nosaltres volem (per exemple: NEW.sou := NEW.sou + 500 si estigu\u00e9rem actualitzant el sou d'un empleat). Els valors tornats per una funci\u00f3 trigger de nivell de statement s\u00f3n sempre ignorats, igual que un AFTER de nivell de fila (ja \u00e9s massa tard per actuar), i per tant millor posar que tornen null. Exemple: Modificar valors abans de la inserci\u00f3 (BEFORE INSERT) Si alg\u00fa insereix NULL en nom, el trigger el reempla\u00e7a per 'Desconocido'. CREATE OR REPLACE FUNCTION evitar_nulos() RETURNS TRIGGER AS $$ BEGIN -- Si el campo nombre es NULL, se asigna un valor por defecto IF NEW.nombre IS NULL THEN NEW.nombre := 'Desconocido'; END IF; RETURN NEW; -- Devuelve la fila modificada END; $$ LANGUAGE plpgsql; CREATE TRIGGER trigger_evitar_nulos BEFORE INSERT ON usuarios FOR EACH ROW EXECUTE FUNCTION evitar_nulos(); Exemple: Cancel\u00b7lar una inserci\u00f3 (BEFORE INSERT amb NULL) Si el saldo \u00e9s menor que 0, es cancel\u00b7la la inserci\u00f3 CREATE OR REPLACE FUNCTION bloquear_insercion() RETURNS TRIGGER AS $$ BEGIN IF NEW.saldo < 0 THEN RAISE EXCEPTION 'No se permiten saldos negativos'; RETURN NULL; -- Cancela la inserci\u00f3n END IF; RETURN NEW; END; $$ LANGUAGE plpgsql; CREATE TRIGGER trigger_bloqueo BEFORE INSERT ON cuentas FOR EACH ROW EXECUTE FUNCTION bloquear_insercion(); Anem a veure uns altres exemples en la base de dades geo_grup_9999x : Exemple : impedir que es modifique el nombre d'habitants d'una localitat en m\u00e9s de 50000 persones (augmentant o disminuint). Nom\u00e9s t\u00e9 sentit el control quan es modifique la columna poblacio . No t\u00e9 sentit ni en inserir ni en esborrar una fila. I ens conv\u00e9 abans d\u2019actualitzar, per poder impedir-ho. CREATE FUNCTION val_50000() RETURNS TRIGGER AS $cos$ BEGIN IF abs(NEW.poblacio - OLD.poblacio) > 50000 THEN RAISE EXCEPTION 'Massa difer\u00e8ncia. No pot ser!!'; END IF; RETURN NEW; END; $cos$ LANGUAGE plpgsql; CREATE TRIGGER tr_val_50000 BEFORE UPDATE ON POBLACIONS FOR EACH ROW EXECUTE PROCEDURE val_50000(); Podr\u00edem comprovar el funcionament del trigger actualitzant alguna fila de la taula POBLACIONS: UPDATE POBLACIONS SET poblacio = 1000 WHERE nom='Castell\u00f3 de la Plana'; Com veieu estem intentant actualitzar la poblaci\u00f3 de Castell\u00f3 de la Plana a 1.000 habitants. Com que la poblaci\u00f3 actual \u00e9s de 173.841, hi haur\u00e0 una difer\u00e8ncia de m\u00e9s de 50.000 habitants, i per tant el trigger impedir\u00e0 l'actualitzaci\u00f3: Nota En DBeaver veurem els triggers en la taula a la qual afecten. Mirem un altre exemple : un trigger que actualitza autom\u00e0ticament el nombre d'instituts de la taula PROVINCIES (teniu la sent\u00e8ncia de creaci\u00f3 en la pregunta 0 d'aquest tema) quan s'insereix o s'esborra un institut. Primer s'haur\u00e0 de mirar la prov\u00edncia de l'institut que s'est\u00e0 introduint o esborrant, i despr\u00e9s s'incrementa o decrementa el nombre d'instituts de la prov\u00edncia: CREATE OR REPLACE FUNCTION act_inst() RETURNS TRIGGER AS $cos$ DECLARE aux text; BEGIN IF TG_OP='INSERT' THEN SELECT provincia INTO aux FROM POBLACIONS,COMARQUES WHERE POBLACIONS.nom_c=COMARQUES.nom_c AND POBLACIONS.cod_m = NEW.cod_m; UPDATE PROVINCIES SET instituts = instituts + 1 WHERE provincia = aux; ELSE SELECT provincia INTO aux FROM POBLACIONS,COMARQUES WHERE POBLACIONS.nom_c=COMARQUES.nom_c AND POBLACIONS.cod_m = OLD.cod_m; UPDATE PROVINCIES SET instituts = instituts - 1 WHERE provincia = aux; END IF; RETURN NEW; END; $cos$ LANGUAGE plpgsql; CREATE TRIGGER tr_act_inst AFTER INSERT OR DELETE ON INSTITUTS FOR EACH ROW EXECUTE PROCEDURE act_inst(); Podrem comprovar-ho, per exemple, introduint un nou registre. Abans de l'actualitzaci\u00f3, el contingut de la taula PROVINCIES \u00e9s: Inserim ara el nou institut, corresponent a Castell\u00f3 (el codi del municipi \u00e9s 12040) INSERT INTO INSTITUTS VALUES ('12004299','IES MARJALERIA','CAM\u00cd LA PLANA','S/N',12003,12040); El contingut de la taula PROVINCIES \u00e9s ara: Un \u00faltim exemple per a veure el de FOR EACH STATEMENT . Intentarem fer un trigger per a que actualitze la poblaci\u00f3 de les prov\u00edncies. Ara anem a plantejar-lo de manera que calcule una altra vegada el total de les poblacions. Per tant, segurament \u00e9s millor calcular-ho quantes menys vegades millor; \u00e9s a dir, si es fan unes quantes actualitzacions de les poblacions, doncs calcular al final de totes elles (i no despr\u00e9s de cadascuna). CREATE OR REPLACE FUNCTION act_pobl() RETURNS TRIGGER AS $cos$ BEGIN UPDATE PROVINCIES SET habitants = (SELECT SUM(poblacio) FROM COMARQUES,POBLACIONS WHERE COMARQUES.nom_c=POBLACIONS.nom_c and provincia=PROVINCIES.provincia); RETURN NEW; END; $cos$ LANGUAGE plpgsql; CREATE TRIGGER tr_act_pobl AFTER INSERT OR DELETE OR UPDATE ON POBLACIONS FOR EACH STATEMENT EXECUTE PROCEDURE act_pobl(); Per a poder comprovar el resultat del trigger anem a fer una operaci\u00f3 d'actualitzaci\u00f3. Per exemple anem a incrementar cada poblaci\u00f3 de la comarca de l'Alcalat\u00e9n en 10.000 habitants (recordeu que ja tenim un trigger que impedeix augmentar en m\u00e9s de 50.000). UPDATE POBLACIONS SET poblacio = poblacio + 10000 WHERE nom_c = 'Alcalat\u00e9n'; Com que la comarca t\u00e9 9 pobles, la poblaci\u00f3 de la prov\u00edncia de Castell\u00f3 haur\u00e0 augmentat en 90.000 habitants: No oblidem executar l'operaci\u00f3 de restar 10.000 habitants als pobles de la comarca de l'Alcalat\u00e9n, i llevar l'institut de la Marjaleria, per deixar les coses com estaven (encara que nom\u00e9s s\u00f3n dades de prova molt desactualitzades). UPDATE POBLACIONS SET poblacio = poblacio - 10000 WHERE nom_c = 'Alcalat\u00e9n'; DELETE FROM INSTITUTS WHERE codi = '12004299'; Per esborrar un trigger, utilitzarem la instrucci\u00f3 DROP TRIGGER : DROP TRIGGER nom_trigger ON nom_taula; La modificaci\u00f3 d'un trigger ( ALTER TRIGGER) nom\u00e9s permet canviar el nom d'aquest trigger. Pot ser molt \u00fatil en ocasions desactivar un trigger , de manera que no tinga efecte durant una temporada, i tornar a activar-lo m\u00e9s avant. Est\u00e0 clar que sempre podr\u00edem esborrar-lo i tornar a crear-lo quan fa\u00e7a falta, per\u00f2 ser\u00e0 m\u00e9s c\u00f2moda la desactivaci\u00f3. Aquesta operaci\u00f3 es fa en l' ALTER TABLE de la taula a la qual implica el trigger . ALTER TABLE nom_taula [ENABLE | DISABLE] TRIGGER [nom_trigger | ALL | USER ]; Com es pot comprovar, la sent\u00e8ncia permet activar o desactivar un trigger en concret, o tots els triggers (caldr\u00e0 tenir privilegis de superusuari, ja que a\u00e7\u00f2 inclouria els triggers implicits que fan acomplir les restriccions d'integritat, i aix\u00f2 nom\u00e9s ho podria fer un superusuari), o els triggers d'usuari, que s\u00f3n els que no s\u00f3n per implementar les claus externes.","title":"8. Triggers"},{"location":"8_triggers/#exercicis","text":"En la Base de Dades geo_grup_9999x : Ex_12 - Crear un trigger anomenat TR_ALT_POS que controle que l'altura d'una nova poblaci\u00f3 siga estrictament psitiva. La funci\u00f3 en la qual es basa es pot anomenar ALT_POS . Ex_13 - Modificar l'anterior per a que ho controle tamb\u00e9 quan es tracta d'una modificaci\u00f3. Ex_14 - Crear un trigger anomenat TR_EXT_0_1000 que controle que l'extensi\u00f3 d'un municipi (poblaci\u00f3) estiga obligat\u00f2riament entre 0 i 1000, i ha de ser sempre, tant si s'insereix una nova poblaci\u00f3 com si es modifica. Per\u00f2 en aquesta ocasi\u00f3, en compte de traure un error, el que farem ser\u00e0 modificar aquest valor: si \u00e9s major que 1000, li donarem el valor 1000, i si \u00e9s negatiu li posarem 0. Ho aconseguirem modificant NEW.extensio, i com la funci\u00f3 del trigger torna sempre NEW, doncs agafar\u00e0 el nou valor. Anomeneu a la funci\u00f3 EXT_0_1000 . Ex_15 - VOLUNTARI . En la taula POBLACIONS3 tenim controlat que la latitud introdu\u00efda siga correcta per mig del tipus lat, per\u00f2 no en la taula POBLACIONS, on \u00e9s de tipus VARCHAR(50) i per tant es podria introduir una latitud incorrecta molt f\u00e0cilment. Crea un trigger que controle que quan s'introdueix o es modifica la latitud de POBLACIONS siga correcta. Per a aix\u00f2 Els car\u00e0cters 1 i 2 han de ser els graus , que han d'estar entre 00 i 90 El car\u00e0cter 3 ha de ser \u00ba Els car\u00e0cters 4 i 5 formen els minuts , i han d'estar entre 00 i 59 El car\u00e0cter 6 ha de ser ' Els car\u00e0cters 7 i 8 formen els segons , i han d'estar entre 00 i 59 El car\u00e0cter 9 ha de ser \" El car\u00e0cter 10 ha de ser N o S Si no s'acompleix alguna de les restriccions anteriors, ha d'eixir un error dient que la latitud ha d'estar entre 00\u00ba00'00\"N i 90\u00ba00'00\"N , o entre 00\u00ba00'00\"S i 90\u00ba00'00\"S Llicenciat sota la Llic\u00e8ncia Creative Commons Reconeixement NoComercial CompartirIgual 3.0","title":"Exercicis"},{"location":"9_creaci_daltres_objectes_basats_en_funcions/","text":"9. Creaci\u00f3 d'altres objectes basats en funcions Ara que ja sabem crear funcions, i ho hem practicat fins i tot per a crear triggers, podr\u00edem plantejar-nos crear altres objectes, com operadors, operadors de classe, funcions d'agregat, ..., per als quals hem d'utilitzar funcions. Aix\u00ed \u00e9s com veurem l'extensibilitat de PostgreSQL, com \u00e9s de vers\u00e0til i ens podem crear objectes a la nostra mida. Nota En DBeaver, no es visualitzen per defecte tots els tipus d'objectes de la Base de Dades. Per poder visulitzar-los has d'executar la consulta: SELECT * FROM pg_operator 9.1 Operadors Per a definir un nou operador especificarem el s\u00edmbol que utilitzarem, el o els operands i la funci\u00f3 que l'implementa. La sintaxi \u00e9s: CREATE OPERATOR name ( PROCEDURE = funcname [, LEFTARG = lefttype ] [, RIGHTARG = righttype ] [, COMMUTATOR = com_op ] [, NEGATOR = neg_op ] ... ) Hi ha m\u00e9s opcions, que per a la utilitat d'aquest curs obviarem. En el nom de l'operador posarem un o m\u00e9s d'un car\u00e0cters de la seg\u00fcent llista: + - * / < > = ~ ! @ # % ^ & | ` ? Hi ha algunes limitacions, que podem veure en la documentaci\u00f3. Sempre hem de posar la funci\u00f3 que implementa l'operador. Si l'operador \u00e9s d'un \u00fanic operand, l'haurem d'especificar (el de la dreta o de l'esquerra, el que preferim). Si \u00e9s de dos operands s'hauren d'especificar els dos. COMMUTATOR indica un altre operador que funciona igual canviant l'ordre dels par\u00e0metres (en num\u00e8rics el commutador de < \u00e9s > ) NEGATOR indica un altre operador equivalent a negar aquest (en num\u00e8rics el negador de < \u00e9s > = ) Per exemple anem a crear l'operador M\u00c0XIM ( /| ) que calcula el m\u00e0xim entre dos n\u00fameros. Utilitzarem la funci\u00f3 MAX2 que ja tenim creada (\u00e9s l'exercici 4) CREATE OPERATOR /| ( PROCEDURE = MAX2, LEFTARG = numeric, RIGHTARG = numeric); Podem comprovar el seu funcionament amb la sent\u00e8ncia: SELECT 23 /| 15; Recordem que els operadors estan definits per a determinats operands. Aix\u00ed, per exemple, la seg\u00fcent sent\u00e8ncia no funcionar\u00e0 perqu\u00e8 no tenim definit l'operador per a operands de text: SELECT 'Alfa' /| 'Beta'; Per a esborrar un operador utilitzarem la sent\u00e8ncia DROP OPERATOR , al qual \u00fanicament li haurem d'especificar l'operador a esborrar i entre par\u00e8ntesis els tipus implicats DROP OPERATOR /| (numeric, numeric); Tampoc tenim definits els operands de comparaci\u00f3 per al tipus lat , que hav\u00edem creat. I per tant coses com aquesta no funcionen : SELECT * FROM POBLACIONS3 WHERE latitud > '(N,40,0,0)'; I si li posem el tipus del qual es tracta: SELECT * FROM POBLACIONS3 WHERE latitud > '(N,40,0,0)'::lat ORDER BY nom; potser no funcionen b\u00e9. Encara que sembla que va b\u00e9 la cosa: el que ha fet en realitat \u00e9s una comparaci\u00f3 car\u00e0cter a car\u00e0cter Per a demostrar que no funciona b\u00e9 inserim una ciutat que estiga a l'hemisferi sud: Rio de Janeiro (ja hav\u00edem quedat que no importava si es deteriorava la Base de Dades). INSERT INTO POBLACIONS3 VALUES('Rio de Janeiro','(S,22,56,58)'::lat, NULL); I si tornem a executar la sent\u00e8ncia d'abans: SELECT * FROM POBLACIONS3 WHERE latitud > '(N,40,0,0)'::lat ORDER BY nom; ara ja es veu que va malament: Anem a intentar crear tots els operadors de comparaci\u00f3 del tipus lat Comen\u00e7arem per les funcions. No considerem quan un operand \u00e9s nul, per fer-los m\u00e9s senzills. La d'igualtat \u00e9s f\u00e0cil, ja que dos latituds s\u00f3n iguals si ho s\u00f3n tots els membres. Observeu que no hi ha problema per fer la comparaci\u00f3 $1.h=$2.h , ja que s\u00f3n del domini hemi_lat basat en el tipus car\u00e0cter: CREATE FUNCTION igual (lat,lat) RETURNS bool AS ' BEGIN RETURN $1.h=$2.h AND $1.g=$2.g AND $1.m=$2.m AND $1.s=$2.s; END; ' LANGUAGE plpgsql; I ara l'operador: CREATE OPERATOR = (LEFTARG = lat, RIGHTARG = lat, PROCEDURE = igual, COMMUTATOR = = , NEGATOR = <>); Observeu que hem posat el commutador igual a ell mateix i el negador a l'operador distint, encara que no el tenim definit. Ara aquesta instrucci\u00f3 ja funciona: SELECT * FROM POBLACIONS3 WHERE latitud = '(N,39,59,10)'; i fins i tot sap que ha de convertir a lat la cadena de car\u00e0cters (ja que nom\u00e9s t\u00e9 un operador = amb un operand tipus lat ). La funci\u00f3 distint nom\u00e9s ha de negar l'igual. I ja podem gastar l'operador: CREATE FUNCTION distint (lat,lat) RETURNS bool AS ' BEGIN RETURN NOT ($1 = $2); END; ' LANGUAGE plpgsql; CREATE OPERATOR <> (LEFTARG = lat, RIGHTARG = lat, PROCEDURE = distint, COMMUTATOR = <> , NEGATOR = = ); \"Nota important\" Enguany tenim creades moltes Bases de Dades perqu\u00e8 l'alumnat \u00e9s molt extens, i potser tenim un poc saturat el servidor. Siga per l'anterior o per alguna altra causa, estem detectant una sobrec\u00e0rrega entre les crides als operadors nous que estem creant. Per aquesta ra\u00f3, encara que queda molt clara la funci\u00f3 distint (quan no s\u00f3n iguals), en compte d'utilitzar l'operador = ser\u00e0 millor cridar a la funci\u00f3 igual (en definitiva, l'operador = crida a la funci\u00f3 igual, per tant ens estalviem un pas). Com que anirem fent tots els operadors de comparaci\u00f3, si cridem sempre a les funcions i no a altres operadors, al final ens estalviarem molts passos. Per aix\u00f2, millor fer aquesta versi\u00f3 de la funci\u00f3 distint(lat,lat) CREATE OR REPLACE FUNCTION distint(lat, lat) RETURNS bool AS $cos$ BEGIN RETURN NOT igual($1,$2); END; $cos$ LANGUAGE plpgsql; L'operador major \u00e9s un poc m\u00e9s complicat. Hem de considerar una latitud major si est\u00e0 m\u00e9s al nord. Per tant a l'hemisferi nord quan m\u00e9s graus m\u00e9s al nord, per\u00f2 a l'hemisferi sud \u00e9s al rev\u00e9s. CREATE FUNCTION major (lat1 lat, lat2 lat) RETURNS bool AS $cos$ DECLARE aux bool; BEGIN IF lat1.h='N' AND lat2.h='S' THEN aux := TRUE; ELSIF lat1.h='S' AND lat2.h='N' THEN aux := FALSE; ELSIF lat1.h='N' AND lat2.h='N' THEN -- Hemisferi NORD IF lat1.g > lat2.g THEN aux := TRUE; ELSIF lat1.g < lat2.g THEN aux := FALSE; ELSE IF lat1.m > lat2.m THEN aux := TRUE; ELSIF lat1.m < lat2.m THEN aux := FALSE; ELSE IF lat1.s > lat2.s THEN aux := TRUE; ELSE aux := FALSE; -- si s\u00f3n iguals \u00e9s fals END IF; END IF; END IF; ELSE -- Hemisferi SUD, al rev\u00e9s que al NORD IF lat1.g < lat2.g THEN aux := TRUE; ELSIF lat1.g > lat2.g THEN aux := FALSE; ELSE IF lat1.m < lat2.m THEN aux := TRUE; ELSIF lat1.m > lat2.m THEN aux := FALSE; ELSE IF lat1.s < lat2.s THEN aux := TRUE; ELSE aux := FALSE; END IF; END IF; END IF; END IF; RETURN aux; END; $cos$ LANGUAGE plpgsql; Segurament podria haver quedat m\u00e9s curt, per\u00f2 aix\u00ed crec que s'ent\u00e9n molt b\u00e9. Ara l'operador: CREATE OPERATOR > (LEFTARG = lat, RIGHTARG = lat, PROCEDURE = major, COMMUTATOR = < , NEGATOR = <= ); Podr\u00edem provar-lo aix\u00ed: SELECT * FROM POBLACIONS3 WHERE latitud > '(N,40,0,0)' ORDER BY NOM; i podrem comprovar que Rio de Janeiro no apareixer\u00e0. Afortunadament tots els altres operadors es poden derivar dels que ja tenim: CREATE OR REPLACE FUNCTION major_igual (lat,lat) RETURNS bool AS ' BEGIN RETURN ($1 > $2) OR ($1=$2); END; ' LANGUAGE plpgsql; CREATE OPERATOR >= (LEFTARG = lat, RIGHTARG = lat, PROCEDURE = major_igual, COMMUTATOR = <= , NEGATOR = < ); I el menor seria negant el major o igual i el menor o igual negant el major. \"Nota important\" Per la mateixa ra\u00f3 de la nota anterior, millor fer aquesta versi\u00f3 de la funci\u00f3 major_igual(lat,lat) : CREATE OR REPLACE FUNCTION major_igual (lat,lat) RETURNS bool AS ' BEGIN RETURN major($1,$2) OR igual($1,$2); END; ' LANGUAGE plpgsql; I exactament igual amb les funcions menor(lat,lat) i menor_igual(lat,lat) Exercicis En la Base de Dades geo_grup_9999x : Ex_16 - Crear els dos operadors de comparaci\u00f3 que quedaven per al tipus lat : < * i * < = . Primer haureu de crear les 2 funcions que queden: menor(lat,lat) i menor_igual(lat,lat) 9.2 Operadors de classe Hem fet els operadors de comparaci\u00f3 per a un nou tipus de dades que hem creat, per\u00f2 a pesar d'aix\u00f2, no podem ordenar per un camp d'aquest tipus, \u00e9s a dir, consultes com la seg\u00fcent encara no funcionen: SELECT * FROM POBLACIONS3 ORDER BY latitud DESC; observeu com la primera \u00e9s Rio de Janeiro, quan havia de ser l'\u00faltima. Ens falta un pas m\u00e9s, construir un OPERADOR DE CLASSE ( OPERATOR CLASS ), que permetr\u00e0 indexar per un camp d'aquest tipus. Aix\u00f2 suposar\u00e0 que podrem ordenar de forma ascendent o descendent, i que podrem crear \u00edndex formats per camps d'aquest tipus; fins i tot podr\u00e0 ser, a partir d'aquest moment, clau principal. Una vegada tenim tots els operadors de comparaci\u00f3, nom\u00e9s ens resta crear una funci\u00f3 de suport a l'operador i definir pr\u00f2piament l'operador de classe. Nota Abans de continuar, estigueu segurs que teniu tots els operadors creats, incloent < i < = La funci\u00f3 de suport ha de tenir dos par\u00e0metres del tipus que volem, i tornar -1, 1 o 0, depenent de si el primer operand \u00e9s menor, major o igual que el segon, respectivament. CREATE OR REPLACE FUNCTION lat_cmp(lat1 lat,lat2 lat) RETURNS integer AS $cos$ BEGIN IF lat1 < lat2 THEN return -1; ELSEIF lat1 > lat2 THEN return 1; ELSE return 0; END IF; END; $cos$ LANGUAGE 'plpgsql'; Ara ja podem definir l'operador de classe. Haurem de tenir privilegis d'administraci\u00f3 (per evitar que qualsevol usuari puga crear operadors de classe). Haurem d'especificar: El tipus de dades per a qui definim l'operador de classe. El m\u00e8tode d'indexaci\u00f3 que utilitzarem (normalment btree , b-arbre ) L'estrat\u00e8gia d'ordenaci\u00f3, especificant quins s\u00f3n els nostres operadors i associant-los a n\u00fameros. Tamb\u00e9 haurem d'especificar la funci\u00f3 de suport. Lamentablement no teniu privilegis d'administraci\u00f3, per tant aquesta part no la podreu fer, \u00fanicament us podreu fiar. La definici\u00f3 de l'operador de classe quedar\u00e0 aix\u00ed : CREATE OPERATOR CLASS lat_op_cl DEFAULT FOR TYPE lat USING btree AS OPERATOR 1 <, OPERATOR 2 <=, OPERATOR 3 =, OPERATOR 4 >=, OPERATOR 5 >, FUNCTION 1 lat_cmp(lat, lat); Si esteu molt molt interessats i voleu comprovar-lo, m'ho dieu a mi i us crear\u00e9 aquest operador de classe. Ara ja ens funcionaria la seg\u00fcent sent\u00e8ncia: SELECT * FROM POBLACIONS3 ORDER BY latitud DESC; observeu com estem ordenant de forma ascendent, i la primera \u00e9s Rio de Janeiro: I fins i tot, si f\u00f3ra el cas, podr\u00edem definir el camp latitud com a clau principal, que no \u00e9s el cas perqu\u00e8 ja \u00e9s nom . 9.3 Funcions d'agregat En PostgreSQL tamb\u00e9 podem definir funcions d'agregat, de l'estil de MAX , SUM , AVG , ... Podem fer-ho sobre qualsevol tipus, existent o definit per l'usuari Una funci\u00f3 d'agregat vindr\u00e0 definida pel seu nom i pel tipus de dades. Per aix\u00f2 encara no funciona la sent\u00e8ncia SELECT MAX(latitud) FROM POBLACIONS3; ja que MAX no est\u00e0 definida sobre el tipus de dades nou. A banda del tipus de dades, podrem jugar amb un tipus de dades intern, mentre es calcula la funci\u00f3 d'agregat, que no t\u00e9 per qu\u00e8 ser igual al tipus de dades de la funci\u00f3. I la funci\u00f3 d'agregat vindr\u00e0 definida per una o dues funcions: una funci\u00f3 de transici\u00f3 d'estat ( sfunc ) que anir\u00e0 calculant l'estat intern mentre van arribant nous valors; i opcionalment una altra funci\u00f3 final ( ffunc ) per a fer un \u00faltim c\u00e0lcul i donar el valor final (per exemple en la mitjana sfunc anir\u00e0 calculant la suma dels valors, i ffunc haur\u00e0 de dividir pel nombre total d'elements). sfunc( estat-intern, seg\u00fcent-item-dades ) ---> seg\u00fcent-estat-intern ffunc( estat-intern ) ---> valor-final Opcionalment tamb\u00e9 podrem donar un valor inicial. La sintaxi \u00e9s: CREATE AGGREGATE nom ( BASETYPE = tipus_dades, SFUNC = sfunc, STYPE = tipus_dades_intern [ , FINALFUNC = ffunc ] [ , INITCOND = condici\u00f3_inicial ] [ , SORTOP = operador_ordenaci\u00f3 ] ) Anem a crear la funci\u00f3 d'agregat MAX per al tipus de dades lat. Comencem per la funci\u00f3 d'estat, que en aquest cas senzillament anir\u00e0 agafant el m\u00e0xim. \u00c9s, per tant, com la funci\u00f3 que calcula el m\u00e0xim de dos n\u00fameros, per\u00f2 en lat. No tindrem en consideraci\u00f3 els valors nuls, per no complicar la cosa. CREATE OR REPLACE FUNCTION MAX2(lat1 lat,lat2 lat) RETURNS lat AS $cos$ BEGIN IF lat2 > lat1 THEN RETURN lat2; ELSE RETURN lat1; END IF; END; $cos$ LANGUAGE plpgsql; Ara ja va la funci\u00f3 d'agregat: CREATE AGGREGATE MAX ( BASETYPE = lat, SFUNC = MAX2, STYPE = lat, INITCOND = '(S,90,0,0)'); Hem posat com a valor inicial el pol sud, per evitar el problema dels nuls. Si tot ha anat b\u00e9, ja podrem fer consultes com la del principi d'aquesta pregunta. SELECT MAX(latitud) FROM POBLACIONS3; Si hav\u00edem creat tamb\u00e9 l'operador de classe, les podrem complicar ordenant-les. Per exemple, podem traure la latitud m\u00e0xima de cada comarca, ordenades de nord a sud: SELECT comarca,MAX(latitud) FROM POBLACIONS3 GROUP BY comarca ORDER BY MAX(latitud) DESC; Com sempre, la sent\u00e8ncia d'esborrar \u00e9s m\u00e9s senzilla. Per a esborrar una funci\u00f3 d'agregat, hem d'especificar el nom de la funci\u00f3 d'agregat i entre par\u00e8ntesis el tipus implicat: DROP AGGREGATE MAX (lat); Exercicis En la Base de Dades geo_grup_9999x : Ex_17 - Crear la funci\u00f3 d'agregat MIN per al tipus de dades lat . Llicenciat sota la Llic\u00e8ncia Creative Commons Reconeixement NoComercial CompartirIgual 3.0","title":"9. Creaci\u00f3 d'altres objectes basats en funcions"},{"location":"9_creaci_daltres_objectes_basats_en_funcions/#9-creacio-daltres-objectes-basats-en-funcions","text":"Ara que ja sabem crear funcions, i ho hem practicat fins i tot per a crear triggers, podr\u00edem plantejar-nos crear altres objectes, com operadors, operadors de classe, funcions d'agregat, ..., per als quals hem d'utilitzar funcions. Aix\u00ed \u00e9s com veurem l'extensibilitat de PostgreSQL, com \u00e9s de vers\u00e0til i ens podem crear objectes a la nostra mida. Nota En DBeaver, no es visualitzen per defecte tots els tipus d'objectes de la Base de Dades. Per poder visulitzar-los has d'executar la consulta: SELECT * FROM pg_operator","title":"9. Creaci\u00f3 d'altres objectes basats en funcions"},{"location":"9_creaci_daltres_objectes_basats_en_funcions/#91-operadors","text":"Per a definir un nou operador especificarem el s\u00edmbol que utilitzarem, el o els operands i la funci\u00f3 que l'implementa. La sintaxi \u00e9s: CREATE OPERATOR name ( PROCEDURE = funcname [, LEFTARG = lefttype ] [, RIGHTARG = righttype ] [, COMMUTATOR = com_op ] [, NEGATOR = neg_op ] ... ) Hi ha m\u00e9s opcions, que per a la utilitat d'aquest curs obviarem. En el nom de l'operador posarem un o m\u00e9s d'un car\u00e0cters de la seg\u00fcent llista: + - * / < > = ~ ! @ # % ^ & | ` ? Hi ha algunes limitacions, que podem veure en la documentaci\u00f3. Sempre hem de posar la funci\u00f3 que implementa l'operador. Si l'operador \u00e9s d'un \u00fanic operand, l'haurem d'especificar (el de la dreta o de l'esquerra, el que preferim). Si \u00e9s de dos operands s'hauren d'especificar els dos. COMMUTATOR indica un altre operador que funciona igual canviant l'ordre dels par\u00e0metres (en num\u00e8rics el commutador de < \u00e9s > ) NEGATOR indica un altre operador equivalent a negar aquest (en num\u00e8rics el negador de < \u00e9s > = ) Per exemple anem a crear l'operador M\u00c0XIM ( /| ) que calcula el m\u00e0xim entre dos n\u00fameros. Utilitzarem la funci\u00f3 MAX2 que ja tenim creada (\u00e9s l'exercici 4) CREATE OPERATOR /| ( PROCEDURE = MAX2, LEFTARG = numeric, RIGHTARG = numeric); Podem comprovar el seu funcionament amb la sent\u00e8ncia: SELECT 23 /| 15; Recordem que els operadors estan definits per a determinats operands. Aix\u00ed, per exemple, la seg\u00fcent sent\u00e8ncia no funcionar\u00e0 perqu\u00e8 no tenim definit l'operador per a operands de text: SELECT 'Alfa' /| 'Beta'; Per a esborrar un operador utilitzarem la sent\u00e8ncia DROP OPERATOR , al qual \u00fanicament li haurem d'especificar l'operador a esborrar i entre par\u00e8ntesis els tipus implicats DROP OPERATOR /| (numeric, numeric); Tampoc tenim definits els operands de comparaci\u00f3 per al tipus lat , que hav\u00edem creat. I per tant coses com aquesta no funcionen : SELECT * FROM POBLACIONS3 WHERE latitud > '(N,40,0,0)'; I si li posem el tipus del qual es tracta: SELECT * FROM POBLACIONS3 WHERE latitud > '(N,40,0,0)'::lat ORDER BY nom; potser no funcionen b\u00e9. Encara que sembla que va b\u00e9 la cosa: el que ha fet en realitat \u00e9s una comparaci\u00f3 car\u00e0cter a car\u00e0cter Per a demostrar que no funciona b\u00e9 inserim una ciutat que estiga a l'hemisferi sud: Rio de Janeiro (ja hav\u00edem quedat que no importava si es deteriorava la Base de Dades). INSERT INTO POBLACIONS3 VALUES('Rio de Janeiro','(S,22,56,58)'::lat, NULL); I si tornem a executar la sent\u00e8ncia d'abans: SELECT * FROM POBLACIONS3 WHERE latitud > '(N,40,0,0)'::lat ORDER BY nom; ara ja es veu que va malament: Anem a intentar crear tots els operadors de comparaci\u00f3 del tipus lat Comen\u00e7arem per les funcions. No considerem quan un operand \u00e9s nul, per fer-los m\u00e9s senzills. La d'igualtat \u00e9s f\u00e0cil, ja que dos latituds s\u00f3n iguals si ho s\u00f3n tots els membres. Observeu que no hi ha problema per fer la comparaci\u00f3 $1.h=$2.h , ja que s\u00f3n del domini hemi_lat basat en el tipus car\u00e0cter: CREATE FUNCTION igual (lat,lat) RETURNS bool AS ' BEGIN RETURN $1.h=$2.h AND $1.g=$2.g AND $1.m=$2.m AND $1.s=$2.s; END; ' LANGUAGE plpgsql; I ara l'operador: CREATE OPERATOR = (LEFTARG = lat, RIGHTARG = lat, PROCEDURE = igual, COMMUTATOR = = , NEGATOR = <>); Observeu que hem posat el commutador igual a ell mateix i el negador a l'operador distint, encara que no el tenim definit. Ara aquesta instrucci\u00f3 ja funciona: SELECT * FROM POBLACIONS3 WHERE latitud = '(N,39,59,10)'; i fins i tot sap que ha de convertir a lat la cadena de car\u00e0cters (ja que nom\u00e9s t\u00e9 un operador = amb un operand tipus lat ). La funci\u00f3 distint nom\u00e9s ha de negar l'igual. I ja podem gastar l'operador: CREATE FUNCTION distint (lat,lat) RETURNS bool AS ' BEGIN RETURN NOT ($1 = $2); END; ' LANGUAGE plpgsql; CREATE OPERATOR <> (LEFTARG = lat, RIGHTARG = lat, PROCEDURE = distint, COMMUTATOR = <> , NEGATOR = = ); \"Nota important\" Enguany tenim creades moltes Bases de Dades perqu\u00e8 l'alumnat \u00e9s molt extens, i potser tenim un poc saturat el servidor. Siga per l'anterior o per alguna altra causa, estem detectant una sobrec\u00e0rrega entre les crides als operadors nous que estem creant. Per aquesta ra\u00f3, encara que queda molt clara la funci\u00f3 distint (quan no s\u00f3n iguals), en compte d'utilitzar l'operador = ser\u00e0 millor cridar a la funci\u00f3 igual (en definitiva, l'operador = crida a la funci\u00f3 igual, per tant ens estalviem un pas). Com que anirem fent tots els operadors de comparaci\u00f3, si cridem sempre a les funcions i no a altres operadors, al final ens estalviarem molts passos. Per aix\u00f2, millor fer aquesta versi\u00f3 de la funci\u00f3 distint(lat,lat) CREATE OR REPLACE FUNCTION distint(lat, lat) RETURNS bool AS $cos$ BEGIN RETURN NOT igual($1,$2); END; $cos$ LANGUAGE plpgsql; L'operador major \u00e9s un poc m\u00e9s complicat. Hem de considerar una latitud major si est\u00e0 m\u00e9s al nord. Per tant a l'hemisferi nord quan m\u00e9s graus m\u00e9s al nord, per\u00f2 a l'hemisferi sud \u00e9s al rev\u00e9s. CREATE FUNCTION major (lat1 lat, lat2 lat) RETURNS bool AS $cos$ DECLARE aux bool; BEGIN IF lat1.h='N' AND lat2.h='S' THEN aux := TRUE; ELSIF lat1.h='S' AND lat2.h='N' THEN aux := FALSE; ELSIF lat1.h='N' AND lat2.h='N' THEN -- Hemisferi NORD IF lat1.g > lat2.g THEN aux := TRUE; ELSIF lat1.g < lat2.g THEN aux := FALSE; ELSE IF lat1.m > lat2.m THEN aux := TRUE; ELSIF lat1.m < lat2.m THEN aux := FALSE; ELSE IF lat1.s > lat2.s THEN aux := TRUE; ELSE aux := FALSE; -- si s\u00f3n iguals \u00e9s fals END IF; END IF; END IF; ELSE -- Hemisferi SUD, al rev\u00e9s que al NORD IF lat1.g < lat2.g THEN aux := TRUE; ELSIF lat1.g > lat2.g THEN aux := FALSE; ELSE IF lat1.m < lat2.m THEN aux := TRUE; ELSIF lat1.m > lat2.m THEN aux := FALSE; ELSE IF lat1.s < lat2.s THEN aux := TRUE; ELSE aux := FALSE; END IF; END IF; END IF; END IF; RETURN aux; END; $cos$ LANGUAGE plpgsql; Segurament podria haver quedat m\u00e9s curt, per\u00f2 aix\u00ed crec que s'ent\u00e9n molt b\u00e9. Ara l'operador: CREATE OPERATOR > (LEFTARG = lat, RIGHTARG = lat, PROCEDURE = major, COMMUTATOR = < , NEGATOR = <= ); Podr\u00edem provar-lo aix\u00ed: SELECT * FROM POBLACIONS3 WHERE latitud > '(N,40,0,0)' ORDER BY NOM; i podrem comprovar que Rio de Janeiro no apareixer\u00e0. Afortunadament tots els altres operadors es poden derivar dels que ja tenim: CREATE OR REPLACE FUNCTION major_igual (lat,lat) RETURNS bool AS ' BEGIN RETURN ($1 > $2) OR ($1=$2); END; ' LANGUAGE plpgsql; CREATE OPERATOR >= (LEFTARG = lat, RIGHTARG = lat, PROCEDURE = major_igual, COMMUTATOR = <= , NEGATOR = < ); I el menor seria negant el major o igual i el menor o igual negant el major. \"Nota important\" Per la mateixa ra\u00f3 de la nota anterior, millor fer aquesta versi\u00f3 de la funci\u00f3 major_igual(lat,lat) : CREATE OR REPLACE FUNCTION major_igual (lat,lat) RETURNS bool AS ' BEGIN RETURN major($1,$2) OR igual($1,$2); END; ' LANGUAGE plpgsql; I exactament igual amb les funcions menor(lat,lat) i menor_igual(lat,lat)","title":"9.1 Operadors"},{"location":"9_creaci_daltres_objectes_basats_en_funcions/#exercicis","text":"En la Base de Dades geo_grup_9999x : Ex_16 - Crear els dos operadors de comparaci\u00f3 que quedaven per al tipus lat : < * i * < = . Primer haureu de crear les 2 funcions que queden: menor(lat,lat) i menor_igual(lat,lat)","title":"Exercicis"},{"location":"9_creaci_daltres_objectes_basats_en_funcions/#92-operadors-de-classe","text":"Hem fet els operadors de comparaci\u00f3 per a un nou tipus de dades que hem creat, per\u00f2 a pesar d'aix\u00f2, no podem ordenar per un camp d'aquest tipus, \u00e9s a dir, consultes com la seg\u00fcent encara no funcionen: SELECT * FROM POBLACIONS3 ORDER BY latitud DESC; observeu com la primera \u00e9s Rio de Janeiro, quan havia de ser l'\u00faltima. Ens falta un pas m\u00e9s, construir un OPERADOR DE CLASSE ( OPERATOR CLASS ), que permetr\u00e0 indexar per un camp d'aquest tipus. Aix\u00f2 suposar\u00e0 que podrem ordenar de forma ascendent o descendent, i que podrem crear \u00edndex formats per camps d'aquest tipus; fins i tot podr\u00e0 ser, a partir d'aquest moment, clau principal. Una vegada tenim tots els operadors de comparaci\u00f3, nom\u00e9s ens resta crear una funci\u00f3 de suport a l'operador i definir pr\u00f2piament l'operador de classe. Nota Abans de continuar, estigueu segurs que teniu tots els operadors creats, incloent < i < = La funci\u00f3 de suport ha de tenir dos par\u00e0metres del tipus que volem, i tornar -1, 1 o 0, depenent de si el primer operand \u00e9s menor, major o igual que el segon, respectivament. CREATE OR REPLACE FUNCTION lat_cmp(lat1 lat,lat2 lat) RETURNS integer AS $cos$ BEGIN IF lat1 < lat2 THEN return -1; ELSEIF lat1 > lat2 THEN return 1; ELSE return 0; END IF; END; $cos$ LANGUAGE 'plpgsql'; Ara ja podem definir l'operador de classe. Haurem de tenir privilegis d'administraci\u00f3 (per evitar que qualsevol usuari puga crear operadors de classe). Haurem d'especificar: El tipus de dades per a qui definim l'operador de classe. El m\u00e8tode d'indexaci\u00f3 que utilitzarem (normalment btree , b-arbre ) L'estrat\u00e8gia d'ordenaci\u00f3, especificant quins s\u00f3n els nostres operadors i associant-los a n\u00fameros. Tamb\u00e9 haurem d'especificar la funci\u00f3 de suport. Lamentablement no teniu privilegis d'administraci\u00f3, per tant aquesta part no la podreu fer, \u00fanicament us podreu fiar. La definici\u00f3 de l'operador de classe quedar\u00e0 aix\u00ed : CREATE OPERATOR CLASS lat_op_cl DEFAULT FOR TYPE lat USING btree AS OPERATOR 1 <, OPERATOR 2 <=, OPERATOR 3 =, OPERATOR 4 >=, OPERATOR 5 >, FUNCTION 1 lat_cmp(lat, lat); Si esteu molt molt interessats i voleu comprovar-lo, m'ho dieu a mi i us crear\u00e9 aquest operador de classe. Ara ja ens funcionaria la seg\u00fcent sent\u00e8ncia: SELECT * FROM POBLACIONS3 ORDER BY latitud DESC; observeu com estem ordenant de forma ascendent, i la primera \u00e9s Rio de Janeiro: I fins i tot, si f\u00f3ra el cas, podr\u00edem definir el camp latitud com a clau principal, que no \u00e9s el cas perqu\u00e8 ja \u00e9s nom .","title":"9.2 Operadors de classe"},{"location":"9_creaci_daltres_objectes_basats_en_funcions/#93-funcions-dagregat","text":"En PostgreSQL tamb\u00e9 podem definir funcions d'agregat, de l'estil de MAX , SUM , AVG , ... Podem fer-ho sobre qualsevol tipus, existent o definit per l'usuari Una funci\u00f3 d'agregat vindr\u00e0 definida pel seu nom i pel tipus de dades. Per aix\u00f2 encara no funciona la sent\u00e8ncia SELECT MAX(latitud) FROM POBLACIONS3; ja que MAX no est\u00e0 definida sobre el tipus de dades nou. A banda del tipus de dades, podrem jugar amb un tipus de dades intern, mentre es calcula la funci\u00f3 d'agregat, que no t\u00e9 per qu\u00e8 ser igual al tipus de dades de la funci\u00f3. I la funci\u00f3 d'agregat vindr\u00e0 definida per una o dues funcions: una funci\u00f3 de transici\u00f3 d'estat ( sfunc ) que anir\u00e0 calculant l'estat intern mentre van arribant nous valors; i opcionalment una altra funci\u00f3 final ( ffunc ) per a fer un \u00faltim c\u00e0lcul i donar el valor final (per exemple en la mitjana sfunc anir\u00e0 calculant la suma dels valors, i ffunc haur\u00e0 de dividir pel nombre total d'elements). sfunc( estat-intern, seg\u00fcent-item-dades ) ---> seg\u00fcent-estat-intern ffunc( estat-intern ) ---> valor-final Opcionalment tamb\u00e9 podrem donar un valor inicial. La sintaxi \u00e9s: CREATE AGGREGATE nom ( BASETYPE = tipus_dades, SFUNC = sfunc, STYPE = tipus_dades_intern [ , FINALFUNC = ffunc ] [ , INITCOND = condici\u00f3_inicial ] [ , SORTOP = operador_ordenaci\u00f3 ] ) Anem a crear la funci\u00f3 d'agregat MAX per al tipus de dades lat. Comencem per la funci\u00f3 d'estat, que en aquest cas senzillament anir\u00e0 agafant el m\u00e0xim. \u00c9s, per tant, com la funci\u00f3 que calcula el m\u00e0xim de dos n\u00fameros, per\u00f2 en lat. No tindrem en consideraci\u00f3 els valors nuls, per no complicar la cosa. CREATE OR REPLACE FUNCTION MAX2(lat1 lat,lat2 lat) RETURNS lat AS $cos$ BEGIN IF lat2 > lat1 THEN RETURN lat2; ELSE RETURN lat1; END IF; END; $cos$ LANGUAGE plpgsql; Ara ja va la funci\u00f3 d'agregat: CREATE AGGREGATE MAX ( BASETYPE = lat, SFUNC = MAX2, STYPE = lat, INITCOND = '(S,90,0,0)'); Hem posat com a valor inicial el pol sud, per evitar el problema dels nuls. Si tot ha anat b\u00e9, ja podrem fer consultes com la del principi d'aquesta pregunta. SELECT MAX(latitud) FROM POBLACIONS3; Si hav\u00edem creat tamb\u00e9 l'operador de classe, les podrem complicar ordenant-les. Per exemple, podem traure la latitud m\u00e0xima de cada comarca, ordenades de nord a sud: SELECT comarca,MAX(latitud) FROM POBLACIONS3 GROUP BY comarca ORDER BY MAX(latitud) DESC; Com sempre, la sent\u00e8ncia d'esborrar \u00e9s m\u00e9s senzilla. Per a esborrar una funci\u00f3 d'agregat, hem d'especificar el nom de la funci\u00f3 d'agregat i entre par\u00e8ntesis el tipus implicat: DROP AGGREGATE MAX (lat);","title":"9.3 Funcions d'agregat"},{"location":"9_creaci_daltres_objectes_basats_en_funcions/#exercicis_1","text":"En la Base de Dades geo_grup_9999x : Ex_17 - Crear la funci\u00f3 d'agregat MIN per al tipus de dades lat . Llicenciat sota la Llic\u00e8ncia Creative Commons Reconeixement NoComercial CompartirIgual 3.0","title":"Exercicis"},{"location":"exercicis_de_tot_el_tema/","text":"Exercicis de tot el tema En la Base de Dades geo_grup_9999x : Ex_1 - Crea una funci\u00f3 anomenada DEU_ Q , que traga els n\u00fameros del 1 al 10 i els seus quadrats . (Utilitza RAISE NOTICE ). Ex_2 - Fes una altra funci\u00f3, IMP , que traga per pantalla els n\u00fameros imparells del 1 al 50. (Utilitza RAISE NOTICE ). Ex_3 - Fes una funci\u00f3 anomenada TAULA_MULT , per a que traga la taula de multiplicar del par\u00e0metre que se li ha de passar. (Utilitza RAISE NOTICE ). Aquest podria ser el seu aspecte, en executar-la: Ex_4 - Fes una funci\u00f3, anomenada MAX2 , que tinga dos par\u00e0metres num\u00e8rics i que torne el m\u00e0xim entre aquestos dos. (Ara ja no s'ha d'utilitzar RAISE NOTICE ). Ex_5 - Utilitza l'anterior per a crear MAX3 . Has d'utilitzar obligat\u00f2riament la funci\u00f3 MAX2 Ex_6 - ( Voluntari ) Fes la funci\u00f3 LAT_A_TEXT , tenint en compte que ha de quedar com en la taula POBLACIONS . Segurament la dificultat m\u00e9s gran ser\u00e0 aconseguir que apareguen les cometes despr\u00e9s dels minuts i dels segons. Ex_7 - Fes una funci\u00f3 anomeneda POBLACIONS_ALTES que accepte 2 par\u00e0metres, el primer de tipus text que ser\u00e0 una comarca, i el segon num\u00e8ric que ser\u00e0 una altura. Ha de traure les poblacions de la comarca del primer par\u00e0metre que s\u00f3n m\u00e9s altes que el segon par\u00e0metre. Mostrarem el nom de la poblaci\u00f3 i l'altura. Aquest podria ser el resultat en executar-se: Ex_8 - Fes una funci\u00f3 anomenada COMARQUES_NUMPOBLES sense par\u00e0metres que traga per pantalla les comarques ordenades alfab\u00e8ticament amb el n\u00famero de pobles de cadascuna Ex_9 - Fes una funci\u00f3 anomenada COMARQUES_NUMPOBLES_NUMINSTITUTS sense par\u00e0metres que traga per pantalla les comarques ordenades alfab\u00e8ticament amb el n\u00famero de pobles de cadascuna i el n\u00famero d'instituts. En la consulta tindrem dos dificultats: Hem d'agafar totes les poblacions, fins i tot les que no tenen institut Com que hem d'accedir als instituts, per a comptar els pobles haurem de comptar els pobles distints, i aix\u00ed si un poble t\u00e9 m\u00e9s d'un institut, no comptar-lo m\u00e9s d'una vegada Ex_10 - Fes una funci\u00f3 anomenada NUM_HABITANTS_COMARCA que accepte un par\u00e0metre de tipus text, i torne el n\u00famero d'habitants d'eixa comarca Ex_11 - Fer la funci\u00f3 COMARQUES_NUMHABITANTS sense par\u00e0metres per a traure per pantalla totes les comarques i el n\u00famero d'habitants. En la consulta has d'utilitzar obligat\u00f2riament la funci\u00f3 anterior Ex_12 - Crear un trigger anomenat TR_ALT_POS que controle que l'altura d'una nova poblaci\u00f3 siga estrictament positiva. La funci\u00f3 en la qual es basa es pot anomenar ALT_POS . Ex_13 - Modificar l'anterior per a que ho controle tamb\u00e9 quan es tracta d'una modificaci\u00f3. Ex_14 - Crear un trigger anomenat TR_EXT_0_1000 que controle que l'extensi\u00f3 d'un municipi (poblaci\u00f3) estiga obligat\u00f2riament entre 0 i 1000, i ha de ser sempre, tant si s'insereix una nova poblaci\u00f3 com si es modifica. Per\u00f2 en aquesta ocasi\u00f3, en compte de traure un error, el que farem ser\u00e0 modificar aquest valor: si \u00e9s major que 1000, li donarem el valor 1000, i si \u00e9s negatiu li posarem 0. Ho aconseguirem modificant NEW.extensio , i com la funci\u00f3 del trigger torna sempre NEW, doncs agafar\u00e0 el nou valor. Anomeneu a la funci\u00f3 EXT_0_1000 . Ex_15 - VOLUNTARI . En la taula POBLACIONS3 tenim controlat que la latitud introdu\u00efda siga correcta per mig del tipus lat, per\u00f2 no en la taula POBLACIONS, on \u00e9s de tipus VARCHAR(50) i per tant es podria introduir una latitud incorrecta molt f\u00e0cilment. Crea un trigger que controle que quan s'introdueix o es modifica la latitud de POBLACIONS siga correcta. Per a aix\u00f2 Els car\u00e0cter 1 i 2 han de ser els graus , que han d'estar entre 00 i 90 El car\u00e0cter 3 ha de ser \u00ba Els car\u00e0cters 4 i 5 formen els minuts , i han d'estar entre 00 i 59 El car\u00e0cter 6 ha de ser ' Els car\u00e0cters 7 i 8 formen els segons , i han d'estar entre 00 i 59 El car\u00e0cter 9 ha de ser \" El car\u00e0cter 10 ha de ser N o S Si no s'acompleix alguna de les restriccions anteriors, ha d'eixir un error dient que la latitud ha d'estar entre 00\u00ba00'00\"N i 90\u00ba00'00\"N , o entre 00\u00ba00'00\"S i 90\u00ba00'00\"S Llicenciat sota la Llic\u00e8ncia Creative Commons Reconeixement NoComercial CompartirIgual 3.0","title":"Exercicis de tot el tema"},{"location":"exercicis_de_tot_el_tema/#exercicis-de-tot-el-tema","text":"En la Base de Dades geo_grup_9999x : Ex_1 - Crea una funci\u00f3 anomenada DEU_ Q , que traga els n\u00fameros del 1 al 10 i els seus quadrats . (Utilitza RAISE NOTICE ). Ex_2 - Fes una altra funci\u00f3, IMP , que traga per pantalla els n\u00fameros imparells del 1 al 50. (Utilitza RAISE NOTICE ). Ex_3 - Fes una funci\u00f3 anomenada TAULA_MULT , per a que traga la taula de multiplicar del par\u00e0metre que se li ha de passar. (Utilitza RAISE NOTICE ). Aquest podria ser el seu aspecte, en executar-la: Ex_4 - Fes una funci\u00f3, anomenada MAX2 , que tinga dos par\u00e0metres num\u00e8rics i que torne el m\u00e0xim entre aquestos dos. (Ara ja no s'ha d'utilitzar RAISE NOTICE ). Ex_5 - Utilitza l'anterior per a crear MAX3 . Has d'utilitzar obligat\u00f2riament la funci\u00f3 MAX2 Ex_6 - ( Voluntari ) Fes la funci\u00f3 LAT_A_TEXT , tenint en compte que ha de quedar com en la taula POBLACIONS . Segurament la dificultat m\u00e9s gran ser\u00e0 aconseguir que apareguen les cometes despr\u00e9s dels minuts i dels segons. Ex_7 - Fes una funci\u00f3 anomeneda POBLACIONS_ALTES que accepte 2 par\u00e0metres, el primer de tipus text que ser\u00e0 una comarca, i el segon num\u00e8ric que ser\u00e0 una altura. Ha de traure les poblacions de la comarca del primer par\u00e0metre que s\u00f3n m\u00e9s altes que el segon par\u00e0metre. Mostrarem el nom de la poblaci\u00f3 i l'altura. Aquest podria ser el resultat en executar-se: Ex_8 - Fes una funci\u00f3 anomenada COMARQUES_NUMPOBLES sense par\u00e0metres que traga per pantalla les comarques ordenades alfab\u00e8ticament amb el n\u00famero de pobles de cadascuna Ex_9 - Fes una funci\u00f3 anomenada COMARQUES_NUMPOBLES_NUMINSTITUTS sense par\u00e0metres que traga per pantalla les comarques ordenades alfab\u00e8ticament amb el n\u00famero de pobles de cadascuna i el n\u00famero d'instituts. En la consulta tindrem dos dificultats: Hem d'agafar totes les poblacions, fins i tot les que no tenen institut Com que hem d'accedir als instituts, per a comptar els pobles haurem de comptar els pobles distints, i aix\u00ed si un poble t\u00e9 m\u00e9s d'un institut, no comptar-lo m\u00e9s d'una vegada Ex_10 - Fes una funci\u00f3 anomenada NUM_HABITANTS_COMARCA que accepte un par\u00e0metre de tipus text, i torne el n\u00famero d'habitants d'eixa comarca Ex_11 - Fer la funci\u00f3 COMARQUES_NUMHABITANTS sense par\u00e0metres per a traure per pantalla totes les comarques i el n\u00famero d'habitants. En la consulta has d'utilitzar obligat\u00f2riament la funci\u00f3 anterior Ex_12 - Crear un trigger anomenat TR_ALT_POS que controle que l'altura d'una nova poblaci\u00f3 siga estrictament positiva. La funci\u00f3 en la qual es basa es pot anomenar ALT_POS . Ex_13 - Modificar l'anterior per a que ho controle tamb\u00e9 quan es tracta d'una modificaci\u00f3. Ex_14 - Crear un trigger anomenat TR_EXT_0_1000 que controle que l'extensi\u00f3 d'un municipi (poblaci\u00f3) estiga obligat\u00f2riament entre 0 i 1000, i ha de ser sempre, tant si s'insereix una nova poblaci\u00f3 com si es modifica. Per\u00f2 en aquesta ocasi\u00f3, en compte de traure un error, el que farem ser\u00e0 modificar aquest valor: si \u00e9s major que 1000, li donarem el valor 1000, i si \u00e9s negatiu li posarem 0. Ho aconseguirem modificant NEW.extensio , i com la funci\u00f3 del trigger torna sempre NEW, doncs agafar\u00e0 el nou valor. Anomeneu a la funci\u00f3 EXT_0_1000 . Ex_15 - VOLUNTARI . En la taula POBLACIONS3 tenim controlat que la latitud introdu\u00efda siga correcta per mig del tipus lat, per\u00f2 no en la taula POBLACIONS, on \u00e9s de tipus VARCHAR(50) i per tant es podria introduir una latitud incorrecta molt f\u00e0cilment. Crea un trigger que controle que quan s'introdueix o es modifica la latitud de POBLACIONS siga correcta. Per a aix\u00f2 Els car\u00e0cter 1 i 2 han de ser els graus , que han d'estar entre 00 i 90 El car\u00e0cter 3 ha de ser \u00ba Els car\u00e0cters 4 i 5 formen els minuts , i han d'estar entre 00 i 59 El car\u00e0cter 6 ha de ser ' Els car\u00e0cters 7 i 8 formen els segons , i han d'estar entre 00 i 59 El car\u00e0cter 9 ha de ser \" El car\u00e0cter 10 ha de ser N o S Si no s'acompleix alguna de les restriccions anteriors, ha d'eixir un error dient que la latitud ha d'estar entre 00\u00ba00'00\"N i 90\u00ba00'00\"N , o entre 00\u00ba00'00\"S i 90\u00ba00'00\"S Llicenciat sota la Llic\u00e8ncia Creative Commons Reconeixement NoComercial CompartirIgual 3.0","title":"Exercicis de tot el tema"},{"location":"exercicis_repas/","text":"Exercicis de rep\u00e0s Cursors Ejercicio C1: Crea una funci\u00f3n que tome el nombre de una comarca como par\u00e1metro y muestre una lista de poblaciones en esa comarca junto con sus habitantes. select lista_poblaciones_por_comarca('Rac\u00f3'); Poblaci\u00f3n: Ademuz -- habitantes:1179 Poblaci\u00f3n: Casas Altas -- habitantes:149 Poblaci\u00f3n: Casas Bajas -- habitantes:195 Poblaci\u00f3n: Castielfabib -- habitantes:282 Poblaci\u00f3n: Vallanca -- habitantes:156 Poblaci\u00f3n: Torrebaja -- habitantes:429 Poblaci\u00f3n: Puebla de San Miguel -- habitantes:71 Ejercicio C2: Crea una funci\u00f3n que muestre el nombre de la comarca y el promedio de altura de todas las poblaciones de la misma comarca, ordenado por comarca. Al final devuelve el n\u00famero total de comarcas. Comarca: Alt Vinalop\u00f3 -- Promedio altura: 580.1428571428571429 Comarca: Baix Maestrat -- Promedio altura: 316.4444444444444444 Comarca: Baix Segura -- Promedio altura: 25.8518518518518519 Comarca: Baix Vinalop\u00f3 -- Promedio altura: 74.0000000000000000 Comarca: Camp de Morvedre -- Promedio altura: 95.3125000000000000 Comarca: Camp de T\u00faria -- Promedio altura: 198.4000000000000000 Comarca: Canal de Navarr\u00e9s -- Promedio altura: 261.5000000000000000 Comarca: Comtat -- Promedio altura: 552.4583333333333333 Comarca: Costera -- Promedio altura: 170.6842105263157895 Comarca: Foia de Bunyol -- Promedio altura: 361.8888888888888889 Comarca: Horta Nord -- Promedio altura: 22.0476190476190476 .............................. total comarcas:34 Ejercicio C3: Crea una funci\u00f3n que muestre el nombre de la poblaci\u00f3n y la cantidad de institutos asociados, incluso los que tienen 0 institutos, ordenado por institutos. ............................ Poblaci\u00f3n: X\u00e0tiva -- Institutos: 3 Poblaci\u00f3n: Xella -- Institutos: 0 Poblaci\u00f3n: Xeraco -- Institutos: 1 Poblaci\u00f3n: Xeresa -- Institutos: 0 Poblaci\u00f3n: Xert -- Institutos: 0 Poblaci\u00f3n: Xilxes -- Institutos: 0 Poblaci\u00f3n: Xirivella -- Institutos: 2 Poblaci\u00f3n: Xixona -- Institutos: 1 Poblaci\u00f3n: Xodos -- Institutos: 0 Poblaci\u00f3n: Y\u00e1tova -- Institutos: 0 Poblaci\u00f3n: Yesa, la -- Institutos: 0 Poblaci\u00f3n: Zarra -- Institutos: 0 Poblaci\u00f3n: Zucaina -- Institutos: 0 Ejercicio C4: Crea una funci\u00f3n que tome el nombre de una comarca como par\u00e1metro y muestre la poblaci\u00f3n y la altura de la poblaci\u00f3n con la altura m\u00e1s alta. select altura_maxima_por_comarca('Alacant\u00ed'); Poblaci\u00f3n: Torre de les Ma\u00e7anes, la -- altura m\u00e1xima: 788 Ejercicio C5: Crea una funci\u00f3n que muestre el nombre y la altura de las poblaciones que tienen alturas superiores al promedio. Poblaci\u00f3n: Ademuz -- altura: 660 Poblaci\u00f3n: Agost -- altura: 376 Poblaci\u00f3n: Agres -- altura: 722 Poblaci\u00f3n: Agullent -- altura: 360 Poblaci\u00f3n: Aig\u00fces -- altura: 341 Poblaci\u00f3n: A\u00edn -- altura: 498 Poblaci\u00f3n: Albaida -- altura: 315 Poblaci\u00f3n: Alboc\u00e0sser -- altura: 538 Poblaci\u00f3n: Alborache -- altura: 320 Ejercicio C6: Crea una funci\u00f3n que tome dos nombres de provincias como par\u00e1metros y devuelva la diferencia absoluta de poblaci\u00f3n entre ambas provincias. select diferencia_poblacion_entre_provincias('Val\u00e8ncia', 'Alacant'); RETURN: 680.460 Ejercicio C7: Crea una funci\u00f3n que muestre el nombre de las poblaciones que no tienen institutos asociados en la tabla instituts, ordenado por poblaci\u00f3n. Poblaci\u00f3n: Ador Poblaci\u00f3n: Agres Poblaci\u00f3n: Agullent Poblaci\u00f3n: Aielo de Rugat Poblaci\u00f3n: Aig\u00fces Poblaci\u00f3n: A\u00edn Poblaci\u00f3n: Albalat dels Sorells Poblaci\u00f3n: Albalat dels Tarongers Poblaci\u00f3n: Alboc\u00e0sser Poblaci\u00f3n: Alborache Poblaci\u00f3n: Albuixech Poblaci\u00f3n: Alcalal\u00ed Ejercicio C8: Crea una funci\u00f3n que muestre el nombre de las poblaciones que tienen una poblaci\u00f3n por debajo del promedio. Promedio= 9234.0295 Poblaci\u00f3n: Ademuz habitantes: 1179 Poblaci\u00f3n: Ador habitantes: 1411 Poblaci\u00f3n: Agost habitantes: 4752 Poblaci\u00f3n: Agres habitantes: 583 Poblaci\u00f3n: Agullent habitantes: 2435 Poblaci\u00f3n: Aielo de Malferit habitantes: 4657 Poblaci\u00f3n: Aielo de Rugat habitantes: 166 Poblaci\u00f3n: Aig\u00fces habitantes: 984 Poblaci\u00f3n: A\u00edn habitantes: 129 Poblaci\u00f3n: Albaida habitantes: 6031 Ejercicio C9: Crea una funci\u00f3n que dado el nombre de una poblaci\u00f3n y una comarca nos permita establecer la lengua para esa poblaci\u00f3n. SELECT SET_LLENGUA('Almudaina','Comtat','V'); RETURN: void Ejercicio C10: Crea una funci\u00f3n llamada Densidad_centros que dado el nombre de una comarca nos devuelva la cantidad de centros que tiene por unidad de superficie. SELECT DENSIDAD_CENTRES('Plana Alta'); RETURN: 0.0219 Ejercicio C11: La misma funci\u00f3n del ejercicio anterior pero utilizando cursor expl\u00edcito. Ejercicio C12: Crea una funci\u00f3n, utilizando al menos un cursor expl\u00edcito, llamada ALTURA_MITJA, que nos permita obtener la altura media a la que est\u00e1n los centros en funci\u00f3n de la comarca y de la lengua de la poblaci\u00f3n (estos ser\u00e1n los par\u00e1metros de entrada). SELECT ALTURA_MITJA ('Comtat'.'v'); RETURN: 455 Ejercicio C13: Crea una funci\u00f3n, utilizando cursores, llamada POBLACIONS_GRANS que dado el nombre de una comarca nos devuelva los nombres de las poblaciones de la comarca que tienen una poblaci\u00f3n superior en un 50% a la media de poblaci\u00f3n de la provincia. Ejercicio C14: Crea una funci\u00f3n, utilizando cursores, llamada CENTRES_DUO , que dado el nombre de una comarca nos devuelva la cantidad total de centros de las dos poblaciones con mayor n\u00famero de habitantes. Ejercicio C15: Crea una funci\u00f3n llamada INTRODUCIR_INSTITUTO(varchar,varchar,varchar,varchar,numeric,numeric), que acepte los par\u00e1metros indicados, uno por cada campo de la tabla INSTITUTS, que compruebe: Que el primer par\u00e1metro, el c\u00f3digo del instituto, tenga exactamente 8 caracteres y que comience por 03, 12 o 46 (los c\u00f3digos de provincia) Que el c\u00f3digo postal est\u00e9 entre 3001 y 3999, 12001 y 12999 o 46001 y 46999. Observa que el cod_m no har\u00e1 falta comprobarlo, ya que es clave externa y saltar\u00eda el error si no es un c\u00f3digo de municipio existente. select introduir_intitut('46000000','Institut de prova','Castello','s/n',3001,12028); select introduir_intitut('03000000','Institut de prova','Castello','s/n',3001,12028); Triggers Ejercicio T1: Crear un trigger que, despu\u00e9s de una inserci\u00f3n, actualice autom\u00e1ticamente la cantidad total de habitantes en la tabla provincies cada vez que se inserta una nueva poblaci\u00f3n en la tabla poblacions. Ejercicio T2: Crear un trigger que evite la actualizaci\u00f3n del nombre de una poblaci\u00f3n en la tabla poblacions3 si existe la comarca. Ejercicio T3: Crear un trigger que evite la inserci\u00f3n de un nuevo instituto en la tabla instituts si el c\u00f3digo de la poblaci\u00f3n asociada no existe en la tabla poblacions. Ejercicio T4: Crear un trigger, MOD_LLEN, que nos avise cuando una poblaci\u00f3n cambia de lengua mayoritaria. Ejercicio T5: Crea un trigger para llevar una auditor\u00eda de la tabla INSTITUTS para controlar todas las modificaciones que se hacen en la tabla. Para eso, por cada actualizaci\u00f3n hecha introduciremos una fila en la tabla AUDIT_INSTITUT (crearla previamente si no existe) con la siguiente informaci\u00f3n: num_a: es la clave principal de la tabla, que ser\u00e1 un autonum\u00e9rico (SERIAL) operacio: contendr\u00e1 el tipo de operaci\u00f3n de actualizaci\u00f3n realizada en la tabla INSTITUS, que podr\u00e1 ser: INSERT, DELETE o UPDATE codi_institut: c\u00f3digo del instituto afectado por la operaci\u00f3n de actualizaci\u00f3n. usuari: usuario que ha realizado la operaci\u00f3n de actualizaci\u00f3n, se puede obtener con current_user; podr\u00edamos pensar que siempre ser\u00e1 el mismo usuario que hace la operaci\u00f3n, pero en realidad lo puede hacer todo usuario que tenga permiso de acceso a la Base de Datos. En la imagen se puede observar c\u00f3mo el usuario postgres tambi\u00e9n ha hecho una operaci\u00f3n de actualizaci\u00f3n.d\u2019actualitzaci\u00f3 data_op: fecha-hora (timestamp) de la actualtzaci\u00f3n; se puede obtener con la funci\u00f3n now() En la imagen se observa c\u00f3mo se han hecho 3 actualizaciones desde el momento de creaci\u00f3n del trigger, la \u00faltima de ellas realizada por el usuario postgres Ejercicio T6: Crear un trigger que registre autom\u00e1ticamente en una tabla de auditor\u00eda, cada vez que se actualiza la poblaci\u00f3n en la tabla poblacions, pero s\u00f3lo si la poblaci\u00f3n aumenta en m\u00e1s del 10%. En la tabla se guardar\u00e1 el valor de la poblaci\u00f3n antes de ser actualizado. Crear la tabla audit_poblacions previamente, si no existe, con la siguiente informaci\u00f3n: cod_m: c\u00f3dido de poblaci\u00f3n fecha: fecha modificaci\u00f3n poblacion_anterior: poblaci\u00f3n antes de la actualizaci\u00f3n. Llicenciat sota la Llic\u00e8ncia Creative Commons Reconeixement NoComercial CompartirIgual 3.0","title":"Exercicis de rep\u00e0s"},{"location":"exercicis_repas/#exercicis-de-repas","text":"","title":"Exercicis de rep\u00e0s"},{"location":"exercicis_repas/#cursors","text":"Ejercicio C1: Crea una funci\u00f3n que tome el nombre de una comarca como par\u00e1metro y muestre una lista de poblaciones en esa comarca junto con sus habitantes. select lista_poblaciones_por_comarca('Rac\u00f3'); Poblaci\u00f3n: Ademuz -- habitantes:1179 Poblaci\u00f3n: Casas Altas -- habitantes:149 Poblaci\u00f3n: Casas Bajas -- habitantes:195 Poblaci\u00f3n: Castielfabib -- habitantes:282 Poblaci\u00f3n: Vallanca -- habitantes:156 Poblaci\u00f3n: Torrebaja -- habitantes:429 Poblaci\u00f3n: Puebla de San Miguel -- habitantes:71 Ejercicio C2: Crea una funci\u00f3n que muestre el nombre de la comarca y el promedio de altura de todas las poblaciones de la misma comarca, ordenado por comarca. Al final devuelve el n\u00famero total de comarcas. Comarca: Alt Vinalop\u00f3 -- Promedio altura: 580.1428571428571429 Comarca: Baix Maestrat -- Promedio altura: 316.4444444444444444 Comarca: Baix Segura -- Promedio altura: 25.8518518518518519 Comarca: Baix Vinalop\u00f3 -- Promedio altura: 74.0000000000000000 Comarca: Camp de Morvedre -- Promedio altura: 95.3125000000000000 Comarca: Camp de T\u00faria -- Promedio altura: 198.4000000000000000 Comarca: Canal de Navarr\u00e9s -- Promedio altura: 261.5000000000000000 Comarca: Comtat -- Promedio altura: 552.4583333333333333 Comarca: Costera -- Promedio altura: 170.6842105263157895 Comarca: Foia de Bunyol -- Promedio altura: 361.8888888888888889 Comarca: Horta Nord -- Promedio altura: 22.0476190476190476 .............................. total comarcas:34 Ejercicio C3: Crea una funci\u00f3n que muestre el nombre de la poblaci\u00f3n y la cantidad de institutos asociados, incluso los que tienen 0 institutos, ordenado por institutos. ............................ Poblaci\u00f3n: X\u00e0tiva -- Institutos: 3 Poblaci\u00f3n: Xella -- Institutos: 0 Poblaci\u00f3n: Xeraco -- Institutos: 1 Poblaci\u00f3n: Xeresa -- Institutos: 0 Poblaci\u00f3n: Xert -- Institutos: 0 Poblaci\u00f3n: Xilxes -- Institutos: 0 Poblaci\u00f3n: Xirivella -- Institutos: 2 Poblaci\u00f3n: Xixona -- Institutos: 1 Poblaci\u00f3n: Xodos -- Institutos: 0 Poblaci\u00f3n: Y\u00e1tova -- Institutos: 0 Poblaci\u00f3n: Yesa, la -- Institutos: 0 Poblaci\u00f3n: Zarra -- Institutos: 0 Poblaci\u00f3n: Zucaina -- Institutos: 0 Ejercicio C4: Crea una funci\u00f3n que tome el nombre de una comarca como par\u00e1metro y muestre la poblaci\u00f3n y la altura de la poblaci\u00f3n con la altura m\u00e1s alta. select altura_maxima_por_comarca('Alacant\u00ed'); Poblaci\u00f3n: Torre de les Ma\u00e7anes, la -- altura m\u00e1xima: 788 Ejercicio C5: Crea una funci\u00f3n que muestre el nombre y la altura de las poblaciones que tienen alturas superiores al promedio. Poblaci\u00f3n: Ademuz -- altura: 660 Poblaci\u00f3n: Agost -- altura: 376 Poblaci\u00f3n: Agres -- altura: 722 Poblaci\u00f3n: Agullent -- altura: 360 Poblaci\u00f3n: Aig\u00fces -- altura: 341 Poblaci\u00f3n: A\u00edn -- altura: 498 Poblaci\u00f3n: Albaida -- altura: 315 Poblaci\u00f3n: Alboc\u00e0sser -- altura: 538 Poblaci\u00f3n: Alborache -- altura: 320 Ejercicio C6: Crea una funci\u00f3n que tome dos nombres de provincias como par\u00e1metros y devuelva la diferencia absoluta de poblaci\u00f3n entre ambas provincias. select diferencia_poblacion_entre_provincias('Val\u00e8ncia', 'Alacant'); RETURN: 680.460 Ejercicio C7: Crea una funci\u00f3n que muestre el nombre de las poblaciones que no tienen institutos asociados en la tabla instituts, ordenado por poblaci\u00f3n. Poblaci\u00f3n: Ador Poblaci\u00f3n: Agres Poblaci\u00f3n: Agullent Poblaci\u00f3n: Aielo de Rugat Poblaci\u00f3n: Aig\u00fces Poblaci\u00f3n: A\u00edn Poblaci\u00f3n: Albalat dels Sorells Poblaci\u00f3n: Albalat dels Tarongers Poblaci\u00f3n: Alboc\u00e0sser Poblaci\u00f3n: Alborache Poblaci\u00f3n: Albuixech Poblaci\u00f3n: Alcalal\u00ed Ejercicio C8: Crea una funci\u00f3n que muestre el nombre de las poblaciones que tienen una poblaci\u00f3n por debajo del promedio. Promedio= 9234.0295 Poblaci\u00f3n: Ademuz habitantes: 1179 Poblaci\u00f3n: Ador habitantes: 1411 Poblaci\u00f3n: Agost habitantes: 4752 Poblaci\u00f3n: Agres habitantes: 583 Poblaci\u00f3n: Agullent habitantes: 2435 Poblaci\u00f3n: Aielo de Malferit habitantes: 4657 Poblaci\u00f3n: Aielo de Rugat habitantes: 166 Poblaci\u00f3n: Aig\u00fces habitantes: 984 Poblaci\u00f3n: A\u00edn habitantes: 129 Poblaci\u00f3n: Albaida habitantes: 6031 Ejercicio C9: Crea una funci\u00f3n que dado el nombre de una poblaci\u00f3n y una comarca nos permita establecer la lengua para esa poblaci\u00f3n. SELECT SET_LLENGUA('Almudaina','Comtat','V'); RETURN: void Ejercicio C10: Crea una funci\u00f3n llamada Densidad_centros que dado el nombre de una comarca nos devuelva la cantidad de centros que tiene por unidad de superficie. SELECT DENSIDAD_CENTRES('Plana Alta'); RETURN: 0.0219 Ejercicio C11: La misma funci\u00f3n del ejercicio anterior pero utilizando cursor expl\u00edcito. Ejercicio C12: Crea una funci\u00f3n, utilizando al menos un cursor expl\u00edcito, llamada ALTURA_MITJA, que nos permita obtener la altura media a la que est\u00e1n los centros en funci\u00f3n de la comarca y de la lengua de la poblaci\u00f3n (estos ser\u00e1n los par\u00e1metros de entrada). SELECT ALTURA_MITJA ('Comtat'.'v'); RETURN: 455 Ejercicio C13: Crea una funci\u00f3n, utilizando cursores, llamada POBLACIONS_GRANS que dado el nombre de una comarca nos devuelva los nombres de las poblaciones de la comarca que tienen una poblaci\u00f3n superior en un 50% a la media de poblaci\u00f3n de la provincia. Ejercicio C14: Crea una funci\u00f3n, utilizando cursores, llamada CENTRES_DUO , que dado el nombre de una comarca nos devuelva la cantidad total de centros de las dos poblaciones con mayor n\u00famero de habitantes. Ejercicio C15: Crea una funci\u00f3n llamada INTRODUCIR_INSTITUTO(varchar,varchar,varchar,varchar,numeric,numeric), que acepte los par\u00e1metros indicados, uno por cada campo de la tabla INSTITUTS, que compruebe: Que el primer par\u00e1metro, el c\u00f3digo del instituto, tenga exactamente 8 caracteres y que comience por 03, 12 o 46 (los c\u00f3digos de provincia) Que el c\u00f3digo postal est\u00e9 entre 3001 y 3999, 12001 y 12999 o 46001 y 46999. Observa que el cod_m no har\u00e1 falta comprobarlo, ya que es clave externa y saltar\u00eda el error si no es un c\u00f3digo de municipio existente. select introduir_intitut('46000000','Institut de prova','Castello','s/n',3001,12028); select introduir_intitut('03000000','Institut de prova','Castello','s/n',3001,12028);","title":"Cursors"},{"location":"exercicis_repas/#triggers","text":"Ejercicio T1: Crear un trigger que, despu\u00e9s de una inserci\u00f3n, actualice autom\u00e1ticamente la cantidad total de habitantes en la tabla provincies cada vez que se inserta una nueva poblaci\u00f3n en la tabla poblacions. Ejercicio T2: Crear un trigger que evite la actualizaci\u00f3n del nombre de una poblaci\u00f3n en la tabla poblacions3 si existe la comarca. Ejercicio T3: Crear un trigger que evite la inserci\u00f3n de un nuevo instituto en la tabla instituts si el c\u00f3digo de la poblaci\u00f3n asociada no existe en la tabla poblacions. Ejercicio T4: Crear un trigger, MOD_LLEN, que nos avise cuando una poblaci\u00f3n cambia de lengua mayoritaria. Ejercicio T5: Crea un trigger para llevar una auditor\u00eda de la tabla INSTITUTS para controlar todas las modificaciones que se hacen en la tabla. Para eso, por cada actualizaci\u00f3n hecha introduciremos una fila en la tabla AUDIT_INSTITUT (crearla previamente si no existe) con la siguiente informaci\u00f3n: num_a: es la clave principal de la tabla, que ser\u00e1 un autonum\u00e9rico (SERIAL) operacio: contendr\u00e1 el tipo de operaci\u00f3n de actualizaci\u00f3n realizada en la tabla INSTITUS, que podr\u00e1 ser: INSERT, DELETE o UPDATE codi_institut: c\u00f3digo del instituto afectado por la operaci\u00f3n de actualizaci\u00f3n. usuari: usuario que ha realizado la operaci\u00f3n de actualizaci\u00f3n, se puede obtener con current_user; podr\u00edamos pensar que siempre ser\u00e1 el mismo usuario que hace la operaci\u00f3n, pero en realidad lo puede hacer todo usuario que tenga permiso de acceso a la Base de Datos. En la imagen se puede observar c\u00f3mo el usuario postgres tambi\u00e9n ha hecho una operaci\u00f3n de actualizaci\u00f3n.d\u2019actualitzaci\u00f3 data_op: fecha-hora (timestamp) de la actualtzaci\u00f3n; se puede obtener con la funci\u00f3n now() En la imagen se observa c\u00f3mo se han hecho 3 actualizaciones desde el momento de creaci\u00f3n del trigger, la \u00faltima de ellas realizada por el usuario postgres Ejercicio T6: Crear un trigger que registre autom\u00e1ticamente en una tabla de auditor\u00eda, cada vez que se actualiza la poblaci\u00f3n en la tabla poblacions, pero s\u00f3lo si la poblaci\u00f3n aumenta en m\u00e1s del 10%. En la tabla se guardar\u00e1 el valor de la poblaci\u00f3n antes de ser actualizado. Crear la tabla audit_poblacions previamente, si no existe, con la siguiente informaci\u00f3n: cod_m: c\u00f3dido de poblaci\u00f3n fecha: fecha modificaci\u00f3n poblacion_anterior: poblaci\u00f3n antes de la actualizaci\u00f3n. Llicenciat sota la Llic\u00e8ncia Creative Commons Reconeixement NoComercial CompartirIgual 3.0","title":"Triggers"},{"location":"objectius_i_coneixements_previs/","text":"Objectius i Coneixements previs Objectius Com tots els SGBD, PostgreSQL ofereix la possibilitat d'afegir funcions, triggers, ... Per a poder fer aquestos fragments de codi, en PostgreSQL es poden fer en molts llenguatges. Triarem un en concret, el PL/pgSQL i el veurem amb una determinada profunditat. Una vegada coneguda la seua sintaxi, crearem funcions escrites en aquest llenguatge. Insistirem en les funcions que utilitzen cursors. Especial \u00e8mfasi, tamb\u00e9, en la construcci\u00f3 de triggers, per ser elements que ajuden a definir millor una Base de Dades. Finalment acabarem de construir objectes que es basen en funcions. Els objectius , per tant seran: Con\u00e9ixer la possibilitat de crear funcions amb m\u00e9s d'un llenguatge Dominar la sintaxi de PL/pgSQL Crear funcions en PL/pgSQL Utilitzaci\u00f3 correcta de cursors Creaci\u00f3 de triggers Creaci\u00f3 d'altres objectes, com operadors, operadors de classe i funcions d'agregat Coneixements previs Els coneixements previs per a poder seguir aquest tema s\u00f3n 3: Con\u00e8ixer SQL Con\u00e8ixer l'entorn d'un client de PostgreSQL, concretament DBeaver Tenir coneixements de programaci\u00f3 (m\u00f2dul de Programaci\u00f3). Tenir coneixements de Bases de Dades Relacionals Llicenciat sota la Llic\u00e8ncia Creative Commons Reconeixement NoComercial CompartirIgual 3.0","title":"Objectius"},{"location":"objectius_i_coneixements_previs/#objectius-i-coneixements-previs","text":"Objectius Com tots els SGBD, PostgreSQL ofereix la possibilitat d'afegir funcions, triggers, ... Per a poder fer aquestos fragments de codi, en PostgreSQL es poden fer en molts llenguatges. Triarem un en concret, el PL/pgSQL i el veurem amb una determinada profunditat. Una vegada coneguda la seua sintaxi, crearem funcions escrites en aquest llenguatge. Insistirem en les funcions que utilitzen cursors. Especial \u00e8mfasi, tamb\u00e9, en la construcci\u00f3 de triggers, per ser elements que ajuden a definir millor una Base de Dades. Finalment acabarem de construir objectes que es basen en funcions. Els objectius , per tant seran: Con\u00e9ixer la possibilitat de crear funcions amb m\u00e9s d'un llenguatge Dominar la sintaxi de PL/pgSQL Crear funcions en PL/pgSQL Utilitzaci\u00f3 correcta de cursors Creaci\u00f3 de triggers Creaci\u00f3 d'altres objectes, com operadors, operadors de classe i funcions d'agregat Coneixements previs Els coneixements previs per a poder seguir aquest tema s\u00f3n 3: Con\u00e8ixer SQL Con\u00e8ixer l'entorn d'un client de PostgreSQL, concretament DBeaver Tenir coneixements de programaci\u00f3 (m\u00f2dul de Programaci\u00f3). Tenir coneixements de Bases de Dades Relacionals Llicenciat sota la Llic\u00e8ncia Creative Commons Reconeixement NoComercial CompartirIgual 3.0","title":"Objectius i Coneixements previs"}]}